/**
 * Client Cache for offline response storage
 *
 * Provides IndexedDB-based storage for pending quiz responses during network
 * interruptions. Automatically retries submission when connectivity is restored.
 *
 * Requirements: 4.1, 4.2, 4.3, 4.5
 *
 * @module     mod_classengage/client_cache
 * @copyright  2025 Danielle
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
define("mod_classengage/client_cache",["jquery"],(function($){var DB_CONFIG_name="classengage_cache",DB_CONFIG_version=1,DB_CONFIG_storeName="pending_responses",DEFAULTS={maxRetries:5,retryDelay:1e3,maxCacheAge:36e5};function ClientCache(){this.db=null,this.options=$.extend({},DEFAULTS),this.isInitialized=!1,this.connectionManager=null,this.stats={stored:0,submitted:0,failed:0,pending:0},this.eventHandlers={}}ClientCache.prototype.init=function(options){var self=this;return this.options=$.extend({},DEFAULTS,options||{}),new Promise((function(resolve,reject){if(!self.isIndexedDBSupported())return self.useMemoryFallback(),self.isInitialized=!0,void resolve();var request=indexedDB.open(DB_CONFIG_name,DB_CONFIG_version);request.onerror=function(event){console.warn("IndexedDB error, using memory fallback:",event),self.useMemoryFallback(),self.isInitialized=!0,resolve()},request.onsuccess=function(event){self.db=event.target.result,self.isInitialized=!0,self.updatePendingCount(),resolve()},request.onupgradeneeded=function(event){var db=event.target.result;if(!db.objectStoreNames.contains(DB_CONFIG_storeName)){var store=db.createObjectStore(DB_CONFIG_storeName,{keyPath:"id"});store.createIndex("sessionId","sessionId",{unique:!1}),store.createIndex("timestamp","timestamp",{unique:!1}),store.createIndex("status","status",{unique:!1})}}}))},ClientCache.prototype.isIndexedDBSupported=function(){return"undefined"!=typeof indexedDB},ClientCache.prototype.useMemoryFallback=function(){this.memoryStore=[],this.db=null},ClientCache.prototype.generateId=function(){return"resp_"+Date.now()+"_"+Math.random().toString(36).substring(2,11)},ClientCache.prototype.storeResponse=function(response){var self=this,pendingResponse={id:this.generateId(),sessionId:response.sessionId,questionId:response.questionId,answer:response.answer,timestamp:Date.now(),clientTimestamp:response.clientTimestamp||Date.now(),retryCount:0,status:"pending",lastError:null};return new Promise((function(resolve,reject){if(self.isInitialized){if(self.memoryStore)return self.memoryStore.push(pendingResponse),self.stats.stored++,self.stats.pending++,self.emit("stored",pendingResponse),void resolve(pendingResponse);var request=self.db.transaction([DB_CONFIG_storeName],"readwrite").objectStore(DB_CONFIG_storeName).add(pendingResponse);request.onsuccess=function(){self.stats.stored++,self.stats.pending++,self.emit("stored",pendingResponse),resolve(pendingResponse)},request.onerror=function(){reject(new Error("Failed to store response"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.getPendingResponses=function(){var self=this;return new Promise((function(resolve,reject){if(self.isInitialized)if(self.memoryStore){var pending=self.memoryStore.filter((function(r){return"pending"===r.status}));resolve(pending)}else{var request=self.db.transaction([DB_CONFIG_storeName],"readonly").objectStore(DB_CONFIG_storeName).index("status").getAll("pending");request.onsuccess=function(event){resolve(event.target.result||[])},request.onerror=function(){reject(new Error("Failed to get pending responses"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.getPendingBySession=function(sessionId){return this.getPendingResponses().then((function(responses){return responses.filter((function(r){return r.sessionId===sessionId}))}))},ClientCache.prototype.markSubmitted=function(responseId){var self=this;return new Promise((function(resolve,reject){if(self.isInitialized){if(self.memoryStore){var index=self.memoryStore.findIndex((function(r){return r.id===responseId}));return-1!==index&&(self.memoryStore[index].status="submitted",self.stats.submitted++,self.stats.pending=Math.max(0,self.stats.pending-1),self.emit("submitted",{id:responseId})),void resolve()}var store=self.db.transaction([DB_CONFIG_storeName],"readwrite").objectStore(DB_CONFIG_storeName),getRequest=store.get(responseId);getRequest.onsuccess=function(event){var response=event.target.result;if(response){response.status="submitted";var updateRequest=store.put(response);updateRequest.onsuccess=function(){self.stats.submitted++,self.stats.pending=Math.max(0,self.stats.pending-1),self.emit("submitted",{id:responseId}),resolve()},updateRequest.onerror=function(){reject(new Error("Failed to update response"))}}else resolve()},getRequest.onerror=function(){reject(new Error("Failed to get response"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.markFailed=function(responseId,errorMsg){var self=this;return new Promise((function(resolve,reject){if(self.isInitialized){if(self.memoryStore){var index=self.memoryStore.findIndex((function(r){return r.id===responseId}));return-1!==index&&(self.memoryStore[index].retryCount++,self.memoryStore[index].lastError=errorMsg,self.memoryStore[index].retryCount>=self.options.maxRetries&&(self.memoryStore[index].status="failed",self.stats.failed++,self.stats.pending=Math.max(0,self.stats.pending-1),self.emit("failed",{id:responseId,error:errorMsg}))),void resolve()}var store=self.db.transaction([DB_CONFIG_storeName],"readwrite").objectStore(DB_CONFIG_storeName),getRequest=store.get(responseId);getRequest.onsuccess=function(event){var response=event.target.result;if(response){response.retryCount++,response.lastError=errorMsg,response.retryCount>=self.options.maxRetries&&(response.status="failed",self.stats.failed++,self.stats.pending=Math.max(0,self.stats.pending-1),self.emit("failed",{id:responseId,error:errorMsg}));var updateRequest=store.put(response);updateRequest.onsuccess=function(){resolve()},updateRequest.onerror=function(){reject(new Error("Failed to update response"))}}else resolve()},getRequest.onerror=function(){reject(new Error("Failed to get response"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.removeResponse=function(responseId){var self=this;return new Promise((function(resolve,reject){if(self.isInitialized)if(self.memoryStore){var index=self.memoryStore.findIndex((function(r){return r.id===responseId}));-1!==index&&"pending"===self.memoryStore.splice(index,1)[0].status&&(self.stats.pending=Math.max(0,self.stats.pending-1)),resolve()}else{var request=self.db.transaction([DB_CONFIG_storeName],"readwrite").objectStore(DB_CONFIG_storeName).delete(responseId);request.onsuccess=function(){self.updatePendingCount(),resolve()},request.onerror=function(){reject(new Error("Failed to remove response"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.clear=function(){var self=this;return new Promise((function(resolve,reject){if(self.isInitialized){if(self.memoryStore)return self.memoryStore=[],self.stats.pending=0,self.emit("cleared",{}),void resolve();var request=self.db.transaction([DB_CONFIG_storeName],"readwrite").objectStore(DB_CONFIG_storeName).clear();request.onsuccess=function(){self.stats.pending=0,self.emit("cleared",{}),resolve()},request.onerror=function(){reject(new Error("Failed to clear cache"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.cleanup=function(){var self=this,cutoffTime=Date.now()-this.options.maxCacheAge;return new Promise((function(resolve,reject){if(self.isInitialized){if(self.memoryStore)return self.memoryStore=self.memoryStore.filter((function(r){return r.timestamp>cutoffTime})),self.updatePendingCount(),void resolve();var index=self.db.transaction([DB_CONFIG_storeName],"readwrite").objectStore(DB_CONFIG_storeName).index("timestamp"),range=IDBKeyRange.upperBound(cutoffTime),request=index.openCursor(range);request.onsuccess=function(event){var cursor=event.target.result;cursor?(cursor.delete(),cursor.continue()):(self.updatePendingCount(),resolve())},request.onerror=function(){reject(new Error("Failed to cleanup cache"))}}else reject(new Error("Cache not initialized"))}))},ClientCache.prototype.updatePendingCount=function(){var self=this;this.getPendingResponses().then((function(responses){self.stats.pending=responses.length})).catch((function(){}))},ClientCache.prototype.getStats=function(){return $.extend({},this.stats)},ClientCache.prototype.setConnectionManager=function(connectionManager){var self=this;this.connectionManager=connectionManager,connectionManager&&"function"==typeof connectionManager.on&&(connectionManager.on("connected",(function(){self.retryPendingResponses()})),connectionManager.on("reconnected",(function(){self.retryPendingResponses()})))},ClientCache.prototype.retryPendingResponses=function(){var self=this;return this.getPendingResponses().then((function(responses){if(0===responses.length)return Promise.resolve([]);self.emit("retrying",{count:responses.length});var promises=responses.map((function(response){return self.submitCachedResponse(response)}));return Promise.all(promises)})).then((function(results){return self.emit("retryComplete",{results:results}),results}))},ClientCache.prototype.submitCachedResponse=function(cachedResponse){var self=this;return this.connectionManager?this.connectionManager.send("submitanswer",{sessionid:cachedResponse.sessionId,questionid:cachedResponse.questionId,answer:cachedResponse.answer,clienttimestamp:cachedResponse.clientTimestamp}).then((function(response){return response.success?self.markSubmitted(cachedResponse.id).then((function(){return{id:cachedResponse.id,success:!0,islate:response.islate||!1}})):self.isPermanentFailure(response.error)?self.removeResponse(cachedResponse.id).then((function(){return{id:cachedResponse.id,success:!1,error:response.error,permanent:!0}})):self.markFailed(cachedResponse.id,response.error).then((function(){return{id:cachedResponse.id,success:!1,error:response.error}}))})).catch((function(error){return self.markFailed(cachedResponse.id,error.message).then((function(){return{id:cachedResponse.id,success:!1,error:error.message}}))})):Promise.reject(new Error("No connection manager"))},ClientCache.prototype.isPermanentFailure=function(error){if(!error)return!1;return["Duplicate submission","Session not found","Session not active","Question not found","already answered"].some((function(msg){return-1!==error.indexOf(msg)}))},ClientCache.prototype.hasPending=function(){return this.stats.pending>0},ClientCache.prototype.on=function(event,callback){this.eventHandlers[event]||(this.eventHandlers[event]=[]),this.eventHandlers[event].push(callback)},ClientCache.prototype.off=function(event,callback){this.eventHandlers[event]&&(callback?this.eventHandlers[event]=this.eventHandlers[event].filter((function(cb){return cb!==callback})):delete this.eventHandlers[event])},ClientCache.prototype.emit=function(event,data){var handlers=this.eventHandlers[event];handlers&&handlers.forEach((function(callback){try{callback(data)}catch(e){console.error("Error in event handler for "+event+":",e)}}))};var instance=null;return{getInstance:function(){return instance||(instance=new ClientCache),instance},init:function(options){return this.getInstance().init(options)},storeResponse:function(response){return this.getInstance().storeResponse(response)},getPendingResponses:function(){return this.getInstance().getPendingResponses()},getPendingBySession:function(sessionId){return this.getInstance().getPendingBySession(sessionId)},markSubmitted:function(responseId){return this.getInstance().markSubmitted(responseId)},markFailed:function(responseId,error){return this.getInstance().markFailed(responseId,error)},removeResponse:function(responseId){return this.getInstance().removeResponse(responseId)},clear:function(){return this.getInstance().clear()},cleanup:function(){return this.getInstance().cleanup()},getStats:function(){return this.getInstance().getStats()},setConnectionManager:function(connectionManager){this.getInstance().setConnectionManager(connectionManager)},retryPendingResponses:function(){return this.getInstance().retryPendingResponses()},hasPending:function(){return this.getInstance().hasPending()},on:function(event,callback){this.getInstance().on(event,callback)},off:function(event,callback){this.getInstance().off(event,callback)}}}));

//# sourceMappingURL=client_cache.min.js.map