{"version":3,"file":"connection_manager.min.js","sources":["../src/connection_manager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Connection Manager for real-time quiz communication\n *\n * SSE-only mode: Uses Server-Sent Events exclusively for real-time data.\n * api.php is used only for write operations (submit, pause, resume).\n * Polling fallback has been removed to reduce server resource consumption.\n *\n * Requirements: 6.1, 6.2, 6.3, 6.4, 6.5\n *\n * @module     mod_classengage/connection_manager\n * @copyright  2025 Danielle\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine(['jquery'], function ($) {\n\n    /**\n     * Connection status constants\n     * @type {Object}\n     */\n    var STATUS = {\n        DISCONNECTED: 'disconnected',\n        CONNECTING: 'connecting',\n        CONNECTED: 'connected',\n        RECONNECTING: 'reconnecting',\n    };\n\n    /**\n     * Transport type constants\n     * @type {Object}\n     */\n    var TRANSPORT = {\n        SSE: 'sse',\n        POLLING: 'polling',\n        OFFLINE: 'offline',\n    };\n\n    /**\n     * Default configuration options\n     * @type {Object}\n     */\n    var DEFAULTS = {\n        sseEndpoint: '/mod/classengage/sse_handler.php',\n        apiEndpoint: '/mod/classengage/api.php', // Write-only endpoint (SSE-only mode)\n        sseRetryAttempts: 3, // 3 attempts before error (SSE required)\n        reconnectDelay: 1000, // Initial reconnect delay\n        maxReconnectDelay: 30000, // Max reconnect delay\n        connectionTimeout: 10000, // Connection timeout\n    };\n\n    /**\n     * Connection Manager constructor\n     * @constructor\n     */\n    function ConnectionManager() {\n        this.sessionId = null;\n        this.connectionId = null;\n        this.options = $.extend({}, DEFAULTS);\n\n        // State tracking\n        this.status = STATUS.DISCONNECTED;\n        this.transport = TRANSPORT.OFFLINE;\n        this.latency = 0;\n\n        // SSE connection\n        this.eventSource = null;\n        this.sseAttempts = 0;\n\n        // Polling\n        this.pollingTimer = null;\n        this.lastEventId = 0;\n\n        // Reconnection\n        this.reconnectTimer = null;\n        this.reconnectDelay = DEFAULTS.reconnectDelay;\n\n        // Event handlers\n        this.eventHandlers = {};\n\n        // Request tracking for latency calculation\n        this.pendingRequests = {};\n    }\n\n    /**\n     * Initialize connection with session\n     *\n     * @param {number} sessionId Session ID to connect to\n     * @param {Object} options Configuration options\n     * @return {Promise} Resolves when connected\n     */\n    ConnectionManager.prototype.init = function (sessionId, options) {\n        var self = this;\n\n        this.sessionId = sessionId;\n        this.options = $.extend({}, DEFAULTS, options || {});\n        this.connectionId = this.generateConnectionId();\n\n        self.status = STATUS.CONNECTING;\n        self.emit('statuschange', { status: self.status });\n\n        // Try SSE first (Requirement 6.3)\n        return self.connectSSE()\n            .catch(function () {\n                // SSE failed, fall back to polling (Requirement 6.1)\n                return self.startPolling();\n            });\n    };\n\n    /**\n     * Generate a unique connection ID\n     *\n     * @return {string} Connection ID\n     * @private\n     */\n    ConnectionManager.prototype.generateConnectionId = function () {\n        return 'conn_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    };\n\n    /**\n     * Connect using Server-Sent Events\n     *\n     * @return {Promise} Resolves when SSE connected\n     * @private\n     */\n    ConnectionManager.prototype.connectSSE = function () {\n        var self = this;\n\n        return new Promise(function (resolve, reject) {\n            // Check if SSE is supported\n            if (typeof EventSource === 'undefined') {\n                self.sseAttempts = self.options.sseRetryAttempts;\n                reject(new Error('SSE not supported'));\n                return;\n            }\n\n            self.sseAttempts++;\n\n            var url = M.cfg.wwwroot + self.options.sseEndpoint +\n                '?sessionid=' + self.sessionId +\n                '&connectionid=' + encodeURIComponent(self.connectionId) +\n                '&lastEventId=' + self.lastEventId;\n\n            try {\n                self.eventSource = new EventSource(url);\n            } catch (e) {\n                if (self.sseAttempts < self.options.sseRetryAttempts) {\n                    setTimeout(function () {\n                        self.connectSSE().then(resolve).catch(reject);\n                    }, 1000);\n                } else {\n                    reject(new Error('SSE connection failed'));\n                }\n                return;\n            }\n\n            var connectionTimeout = setTimeout(function () {\n                if (self.status !== STATUS.CONNECTED) {\n                    self.closeSSE();\n                    if (self.sseAttempts < self.options.sseRetryAttempts) {\n                        self.connectSSE().then(resolve).catch(reject);\n                    } else {\n                        reject(new Error('SSE connection timeout'));\n                    }\n                }\n            }, self.options.connectionTimeout);\n\n            self.eventSource.onopen = function () {\n                // Connection opened, wait for 'connected' event\n            };\n\n            self.eventSource.onerror = function () {\n                clearTimeout(connectionTimeout);\n                self.closeSSE();\n\n                if (self.sseAttempts < self.options.sseRetryAttempts) {\n                    setTimeout(function () {\n                        self.connectSSE().then(resolve).catch(reject);\n                    }, 1000);\n                } else {\n                    reject(new Error('SSE connection failed after ' + self.sseAttempts + ' attempts'));\n                }\n            };\n\n            // Handle connected event\n            self.eventSource.addEventListener('connected', function (event) {\n                clearTimeout(connectionTimeout);\n                var data = JSON.parse(event.data);\n                self.connectionId = data.connectionid;\n                self.status = STATUS.CONNECTED;\n                self.transport = TRANSPORT.SSE;\n                self.sseAttempts = 0;\n                self.reconnectDelay = DEFAULTS.reconnectDelay;\n                self.lastEventId = parseInt(event.lastEventId) || 0;\n\n                self.emit('statuschange', { status: self.status, transport: self.transport });\n                self.emit('connected', data);\n                resolve();\n            });\n\n            // Register SSE event handlers\n            self.registerSSEHandlers();\n        });\n    };\n\n    /**\n     * Register handlers for SSE events\n     *\n     * @private\n     */\n    ConnectionManager.prototype.registerSSEHandlers = function () {\n        var self = this;\n\n        if (!this.eventSource) {\n            return;\n        }\n\n        var events = [\n            'session_started',\n            'session_paused',\n            'session_resumed',\n            'session_completed',\n            'session_ended',\n            'question_broadcast',\n            'timer_sync',\n            'reconnect',\n            // Note: 'error' removed - conflicts with native EventSource.onerror event\n            // Instructor-only events (SSE-only mode)\n            'stats_update',\n            'students_update',\n        ];\n\n        events.forEach(function (eventType) {\n            self.eventSource.addEventListener(eventType, function (event) {\n                self.lastEventId = parseInt(event.lastEventId) || self.lastEventId;\n\n                // Validate event data exists before parsing\n                if (!event.data || event.data === 'undefined') {\n                    // eslint-disable-next-line no-console\n                    console.warn('SSE event received without valid data:', eventType, event);\n                    return;\n                }\n\n                var data;\n                try {\n                    data = JSON.parse(event.data);\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    console.error('SSE JSON parse error for event:', eventType, 'data:', event.data, e);\n                    return;\n                }\n\n                self.emit(eventType, data);\n\n                // Handle reconnect request from server\n                if (eventType === 'reconnect') {\n                    self.handleReconnectRequest(data);\n                }\n\n                // Handle session end\n                if (eventType === 'session_completed' || eventType === 'session_ended') {\n                    self.disconnect();\n                }\n            });\n        });\n    };\n\n    /**\n     * Close SSE connection\n     *\n     * @private\n     */\n    ConnectionManager.prototype.closeSSE = function () {\n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n        }\n    };\n\n    /**\n     * SSE connection failed fallback - show error (SSE-only mode)\n     *\n     * @return {Promise} Rejects with error message\n     * @private\n     */\n    ConnectionManager.prototype.startPolling = function () {\n        var self = this;\n\n        // SSE-only mode: No polling fallback\n        return new Promise(function (resolve, reject) {\n            self.status = STATUS.DISCONNECTED;\n            self.transport = TRANSPORT.OFFLINE;\n            self.emit('statuschange', { status: self.status, transport: self.transport });\n            self.emit('connection_error', {\n                message: 'SSE connection required. Polling fallback has been removed.',\n                reason: 'sse_required',\n            });\n            reject(new Error('SSE connection required. Please ensure your browser supports Server-Sent Events.'));\n        });\n    };\n\n    // NOTE: startPollingLoop, poll, and pollReconnect have been removed (SSE-only mode)\n    // All real-time data is now pushed via Server-Sent Events\n    // Only write operations (submit, pause, resume) use api.php via send() method\n\n    /**\n     * Stop polling\n     *\n     * @private\n     */\n    ConnectionManager.prototype.stopPolling = function () {\n        if (this.pollingTimer) {\n            clearInterval(this.pollingTimer);\n            this.pollingTimer = null;\n        }\n    };\n\n    /**\n     * Handle connection error\n     *\n     * @private\n     */\n    ConnectionManager.prototype.handleConnectionError = function () {\n        if (this.status === STATUS.DISCONNECTED) {\n            return;\n        }\n\n        this.status = STATUS.RECONNECTING;\n        this.emit('statuschange', { status: this.status });\n        this.emit('disconnected', { reason: 'connection_error' });\n\n        this.scheduleReconnect();\n    };\n\n    /**\n     * Handle reconnect request from server\n     *\n     * @private\n     */\n    ConnectionManager.prototype.handleReconnectRequest = function () {\n        this.closeSSE();\n        this.stopPolling();\n        this.scheduleReconnect();\n    };\n\n    /**\n     * Schedule a reconnection attempt\n     *\n     * @private\n     */\n    ConnectionManager.prototype.scheduleReconnect = function () {\n        var self = this;\n\n        if (this.reconnectTimer) {\n            return;\n        }\n\n        this.reconnectTimer = setTimeout(function () {\n            self.reconnectTimer = null;\n            self.reconnect();\n        }, this.reconnectDelay);\n\n        // Exponential backoff\n        this.reconnectDelay = Math.min(\n            this.reconnectDelay * 2,\n            this.options.maxReconnectDelay,\n        );\n    };\n\n    /**\n     * Force reconnection\n     *\n     * @return {Promise} Resolves when reconnected\n     */\n    ConnectionManager.prototype.reconnect = function () {\n        var self = this;\n\n        // Clear any pending reconnect\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n\n        // Close existing connections\n        this.closeSSE();\n        this.stopPolling();\n\n        this.status = STATUS.RECONNECTING;\n        this.emit('statuschange', { status: this.status });\n\n        // Reset SSE attempts for fresh reconnection\n        this.sseAttempts = 0;\n\n        // Try SSE first, then polling\n        return self.connectSSE()\n            .then(function () {\n                self.emit('reconnected', { transport: self.transport });\n            })\n            .catch(function () {\n                return self.startPolling()\n                    .then(function () {\n                        self.emit('reconnected', { transport: self.transport });\n                    })\n                    .catch(function (error) {\n                        self.status = STATUS.DISCONNECTED;\n                        self.transport = TRANSPORT.OFFLINE;\n                        self.emit('statuschange', { status: self.status, transport: self.transport });\n                        throw error;\n                    });\n            });\n    };\n\n    /**\n     * Send message to server\n     *\n     * @param {string} type Message type (action)\n     * @param {Object} data Message data\n     * @return {Promise} Resolves with server response\n     */\n    ConnectionManager.prototype.send = function (type, data) {\n        var self = this;\n        var startTime = Date.now();\n        var requestId = this.generateConnectionId();\n\n        this.pendingRequests[requestId] = startTime;\n\n        var requestData = $.extend({\n            action: type,\n            sessionid: this.sessionId,\n            connectionid: this.connectionId,\n            sesskey: M.cfg.sesskey,\n        }, data || {});\n\n        return new Promise(function (resolve, reject) {\n            $.ajax({\n                url: M.cfg.wwwroot + self.options.apiEndpoint,\n                method: 'POST',\n                data: requestData,\n                dataType: 'json',\n                timeout: self.options.connectionTimeout,\n            })\n                .done(function (response) {\n                    delete self.pendingRequests[requestId];\n                    self.latency = Date.now() - startTime;\n                    resolve(response);\n                })\n                .fail(function (xhr, status, error) {\n                    delete self.pendingRequests[requestId];\n                    reject(new Error(error || 'Request failed'));\n                });\n        });\n    };\n\n    /**\n     * Register event handler\n     *\n     * @param {string} event Event name\n     * @param {Function} callback Callback function\n     */\n    ConnectionManager.prototype.on = function (event, callback) {\n        if (!this.eventHandlers[event]) {\n            this.eventHandlers[event] = [];\n        }\n        this.eventHandlers[event].push(callback);\n    };\n\n    /**\n     * Remove event handler\n     *\n     * @param {string} event Event name\n     * @param {Function} callback Callback function to remove\n     */\n    ConnectionManager.prototype.off = function (event, callback) {\n        if (!this.eventHandlers[event]) {\n            return;\n        }\n\n        if (callback) {\n            this.eventHandlers[event] = this.eventHandlers[event].filter(function (cb) {\n                return cb !== callback;\n            });\n        } else {\n            delete this.eventHandlers[event];\n        }\n    };\n\n    /**\n     * Emit event to handlers\n     *\n     * @param {string} event Event name\n     * @param {Object} data Event data\n     * @private\n     */\n    ConnectionManager.prototype.emit = function (event, data) {\n        var handlers = this.eventHandlers[event];\n        if (handlers) {\n            handlers.forEach(function (callback) {\n                try {\n                    callback(data);\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    console.error('Error in event handler for ' + event + ':', e);\n                }\n            });\n        }\n    };\n\n    /**\n     * Get current connection status\n     *\n     * @return {Object} Connection status\n     */\n    ConnectionManager.prototype.getStatus = function () {\n        return {\n            connected: this.status === STATUS.CONNECTED,\n            status: this.status,\n            transport: this.transport,\n            latency: this.latency,\n            connectionId: this.connectionId,\n        };\n    };\n\n    /**\n     * Check if currently connected\n     *\n     * @return {boolean} True if connected\n     */\n    ConnectionManager.prototype.isConnected = function () {\n        return this.status === STATUS.CONNECTED;\n    };\n\n    /**\n     * Get current transport type\n     *\n     * @return {string} Transport type\n     */\n    ConnectionManager.prototype.getTransport = function () {\n        return this.transport;\n    };\n\n    /**\n     * Graceful disconnect\n     */\n    ConnectionManager.prototype.disconnect = function () {\n        this.closeSSE();\n        this.stopPolling();\n\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n\n        this.status = STATUS.DISCONNECTED;\n        this.transport = TRANSPORT.OFFLINE;\n\n        this.emit('statuschange', { status: this.status, transport: this.transport });\n        this.emit('disconnected', { reason: 'user_disconnect' });\n    };\n\n    // Export constants for external use\n    ConnectionManager.STATUS = STATUS;\n    ConnectionManager.TRANSPORT = TRANSPORT;\n\n    // Singleton instance\n    var instance = null;\n\n    return {\n        /**\n         * Get or create ConnectionManager instance\n         *\n         * @return {ConnectionManager} Connection manager instance\n         */\n        getInstance: function () {\n            if (!instance) {\n                instance = new ConnectionManager();\n            }\n            return instance;\n        },\n\n        /**\n         * Initialize connection manager with session\n         *\n         * @param {number} sessionId Session ID\n         * @param {Object} options Configuration options\n         * @return {Promise} Resolves when connected\n         */\n        init: function (sessionId, options) {\n            return this.getInstance().init(sessionId, options);\n        },\n\n        /**\n         * Send message to server\n         *\n         * @param {string} type Message type\n         * @param {Object} data Message data\n         * @return {Promise} Resolves with response\n         */\n        send: function (type, data) {\n            return this.getInstance().send(type, data);\n        },\n\n        /**\n         * Register event handler\n         *\n         * @param {string} event Event name\n         * @param {Function} callback Callback function\n         */\n        on: function (event, callback) {\n            this.getInstance().on(event, callback);\n        },\n\n        /**\n         * Remove event handler\n         *\n         * @param {string} event Event name\n         * @param {Function} callback Callback function\n         */\n        off: function (event, callback) {\n            this.getInstance().off(event, callback);\n        },\n\n        /**\n         * Get connection status\n         *\n         * @return {Object} Connection status\n         */\n        getStatus: function () {\n            return this.getInstance().getStatus();\n        },\n\n        /**\n         * Force reconnection\n         *\n         * @return {Promise} Resolves when reconnected\n         */\n        reconnect: function () {\n            return this.getInstance().reconnect();\n        },\n\n        /**\n         * Disconnect from server\n         */\n        disconnect: function () {\n            this.getInstance().disconnect();\n        },\n\n        // Export constants\n        STATUS: STATUS,\n        TRANSPORT: TRANSPORT,\n    };\n});\n"],"names":["define","$","STATUS","DISCONNECTED","CONNECTING","CONNECTED","RECONNECTING","TRANSPORT","SSE","POLLING","OFFLINE","DEFAULTS","sseEndpoint","apiEndpoint","sseRetryAttempts","reconnectDelay","maxReconnectDelay","connectionTimeout","ConnectionManager","sessionId","connectionId","options","extend","status","transport","latency","eventSource","sseAttempts","pollingTimer","lastEventId","reconnectTimer","eventHandlers","pendingRequests","prototype","init","self","this","generateConnectionId","emit","connectSSE","catch","startPolling","Date","now","Math","random","toString","substr","Promise","resolve","reject","EventSource","Error","url","M","cfg","wwwroot","encodeURIComponent","e","setTimeout","then","closeSSE","onopen","onerror","clearTimeout","addEventListener","event","data","JSON","parse","connectionid","parseInt","registerSSEHandlers","forEach","eventType","console","error","handleReconnectRequest","disconnect","warn","close","message","reason","stopPolling","clearInterval","handleConnectionError","scheduleReconnect","reconnect","min","send","type","startTime","requestId","requestData","action","sessionid","sesskey","ajax","method","dataType","timeout","done","response","fail","xhr","on","callback","push","off","filter","cb","handlers","getStatus","connected","isConnected","getTransport","instance","getInstance"],"mappings":"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"}