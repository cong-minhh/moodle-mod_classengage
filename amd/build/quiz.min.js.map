{"version":3,"file":"quiz.min.js","sources":["../src/quiz.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Student quiz interface with real-time updates\n *\n * SSE-only mode: Receives question broadcasts and session state updates\n * exclusively via Server-Sent Events. api.php is used only for\n * answer submissions and session operations.\n *\n * Requirements: 2.4, 4.5, 8.5\n *\n * @module     mod_classengage/quiz\n * @copyright  2025 Danielle\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine([\n    'jquery',\n    'core/ajax',\n    'core/notification',\n    'core/str',\n    'mod_classengage/connection_manager',\n    'mod_classengage/client_cache',\n], function ($, Ajax, Notification, Str, ConnectionManager, ClientCache) {\n\n    /**\n     * Quiz state constants\n     * @type {Object}\n     */\n    var STATE = {\n        WAITING: 'waiting',\n        ACTIVE: 'active',\n        PAUSED: 'paused',\n        COMPLETED: 'completed',\n    };\n\n    /**\n     * Quiz module instance\n     * @type {Object}\n     */\n    var Quiz = {\n        cmid: null,\n        sessionId: null,\n        currentQuestion: null,\n        currentQuestionId: null,\n        pollingTimer: null,\n        countdownTimer: null,\n        isOnline: true,\n        pendingSubmission: null,\n        strings: {},\n        answeredQuestions: {}, // Track which questions user has answered\n\n        // Client-side timer state (enterprise timer separation)\n        timerState: {\n            serverTimeRemaining: 0,    // Last known server time remaining\n            serverTimestamp: 0,        // Server timestamp when we received the sync\n            clientStartTime: 0,        // Client timestamp when countdown started\n            isRunning: false,          // Whether countdown is active\n            isPaused: false,           // Whether timer is paused\n            lastSyncTime: 0,            // Last time we synced with server\n        },\n\n        /**\n         * Initialize the quiz module\n         *\n         * @param {Object} options Initialization options\n         * @param {number} options.cmid Course module ID\n         * @param {number} options.sessionid Session ID\n         * @param {number} options.pollinginterval Polling interval in milliseconds\n         * @param {number} options.timelimit Time limit for current question\n         * @param {number} options.timeremaining Time remaining for current question\n         * @param {number} options.questionid Current question ID\n         * @return {Promise} Resolves when initialized\n         */\n        init: function (options) {\n            var self = this;\n\n            // Handle both object and legacy positional arguments\n            var cmid, sessionid, pollinginterval, timelimit, timeremaining, questionid, hasanswered;\n            if (typeof options === 'object' && options !== null) {\n                cmid = options.cmid;\n                sessionid = options.sessionid;\n                pollinginterval = options.pollinginterval;\n                timelimit = options.timelimit || 0;\n                timeremaining = options.timeremaining || 0;\n                questionid = options.questionid || 0;\n                hasanswered = options.hasanswered || false;\n            } else {\n                // Legacy positional arguments\n                cmid = arguments[0];\n                sessionid = arguments[1];\n                pollinginterval = arguments[2];\n                timelimit = 0;\n                timeremaining = 0;\n                questionid = 0;\n                hasanswered = false;\n            }\n\n            this.cmid = cmid;\n            this.sessionId = sessionid;\n            this.currentQuestionId = questionid;\n\n            // Mark current question as answered if PHP says so\n            if (questionid > 0 && hasanswered) {\n                this.answeredQuestions[questionid] = true;\n            }\n\n            // Load language strings\n            return this.loadStrings().then(function () {\n                // Initialize client cache for offline support\n                return ClientCache.init({\n                    maxRetries: 3,\n                    retryDelay: 2000,\n                });\n            }).then(function () {\n                // Set up connection manager for client cache\n                ClientCache.setConnectionManager(ConnectionManager.getInstance());\n\n                // Initialize connection manager\n                return ConnectionManager.init(sessionid, {\n                    pollInterval: pollinginterval || 2000,\n                });\n            }).then(function () {\n                // Set up event handlers\n                self.setupEventHandlers();\n                self.setupConnectionHandlers();\n                self.setupOfflineIndicator();\n\n                // Handle answer submission\n                $(document).on('click', '.submit-answer-btn', function () {\n                    self.submitAnswer();\n                });\n\n                // Handle touch events for mobile\n                $(document).on('touchend', '.quiz-option', function (e) {\n                    e.preventDefault();\n                    $(this).find('input[type=\"radio\"]').prop('checked', true);\n                    $(this).addClass('selected').siblings().removeClass('selected');\n                });\n\n                // Start timer immediately if we have timer data from PHP\n                if (timeremaining > 0 && timelimit > 0) {\n                    self.startLocalCountdown(timeremaining);\n                }\n\n                // Update quiz status when connected\n                $('#quiz-status').removeClass('d-none').text('Connected');\n                setTimeout(function () {\n                    $('#quiz-status').addClass('d-none');\n                }, 2000);\n\n                return null;\n            }).catch(function (error) {\n                // eslint-disable-next-line no-console\n                console.error('Quiz initialization error:', error);\n                // Fall back to legacy polling if connection manager fails\n                self.startLegacyPolling(pollinginterval);\n            });\n        },\n\n        /**\n         * Load required language strings\n         *\n         * @return {Promise} Resolves when strings are loaded\n         */\n        loadStrings: function () {\n            var self = this;\n            var stringKeys = [\n                { key: 'answersubmitted', component: 'mod_classengage' },\n                { key: 'correct', component: 'mod_classengage' },\n                { key: 'incorrect', component: 'mod_classengage' },\n                { key: 'correctanswer', component: 'mod_classengage' },\n                { key: 'waitingnextquestion', component: 'mod_classengage' },\n                { key: 'quizcompleted', component: 'mod_classengage' },\n                { key: 'alreadyanswered', component: 'mod_classengage' },\n                { key: 'selectanswer', component: 'mod_classengage' },\n                { key: 'error', component: 'core' },\n                { key: 'offline', component: 'mod_classengage' },\n                { key: 'reconnecting', component: 'mod_classengage' },\n                { key: 'connectionrestored', component: 'mod_classengage' },\n                { key: 'submittingoffline', component: 'mod_classengage' },\n                { key: 'pendingsubmissions', component: 'mod_classengage' },\n            ];\n\n            return Str.get_strings(stringKeys).then(function (strings) {\n                self.strings = {\n                    answersubmitted: strings[0],\n                    correct: strings[1],\n                    incorrect: strings[2],\n                    correctanswer: strings[3],\n                    waitingnextquestion: strings[4],\n                    quizcompleted: strings[5],\n                    alreadyanswered: strings[6],\n                    selectanswer: strings[7],\n                    error: strings[8],\n                    offline: strings[9] || 'Offline - responses will be saved locally',\n                    reconnecting: strings[10] || 'Reconnecting...',\n                    connectionrestored: strings[11] || 'Connection restored',\n                    submittingoffline: strings[12] || 'Saving response offline...',\n                    pendingsubmissions: strings[13] || 'Pending submissions',\n                };\n                return null;\n            }).catch(function () {\n                // Use fallback strings if loading fails\n                self.strings = {\n                    answersubmitted: 'Answer submitted!',\n                    correct: 'Correct!',\n                    incorrect: 'Incorrect',\n                    correctanswer: 'Correct Answer',\n                    waitingnextquestion: 'Waiting for next question...',\n                    quizcompleted: 'Quiz completed!',\n                    alreadyanswered: 'You have already answered this question',\n                    selectanswer: 'Please select an answer',\n                    error: 'Error',\n                    offline: 'Offline - responses will be saved locally',\n                    reconnecting: 'Reconnecting...',\n                    connectionrestored: 'Connection restored',\n                    submittingoffline: 'Saving response offline...',\n                    pendingsubmissions: 'Pending submissions',\n                };\n            });\n        },\n\n        /**\n         * Set up connection manager event handlers\n         */\n        setupConnectionHandlers: function () {\n            var self = this;\n\n            // Handle connection status changes\n            ConnectionManager.on('statuschange', function (data) {\n                self.handleConnectionStatusChange(data);\n            });\n\n            // Handle session state updates from server\n            ConnectionManager.on('state_update', function (data) {\n                self.handleStateUpdate(data);\n            });\n\n            // Handle question broadcasts\n            ConnectionManager.on('question_broadcast', function (data) {\n                self.handleQuestionBroadcast(data);\n            });\n\n            // Handle session events\n            ConnectionManager.on('session_started', function (data) {\n                self.handleSessionStarted(data);\n            });\n\n            ConnectionManager.on('session_paused', function (data) {\n                self.handleSessionPaused(data);\n            });\n\n            ConnectionManager.on('session_resumed', function (data) {\n                self.handleSessionResumed(data);\n            });\n\n            ConnectionManager.on('session_completed', function (data) {\n                self.handleSessionCompleted(data);\n            });\n\n            // Handle timer sync from server (only for drift correction)\n            ConnectionManager.on('timer_sync', function (data) {\n                self.syncServerTime(data);\n            });\n\n            // Handle reconnection\n            ConnectionManager.on('reconnected', function () {\n                self.handleReconnected();\n            });\n\n            // Handle disconnection\n            ConnectionManager.on('disconnected', function () {\n                self.handleDisconnected();\n            });\n        },\n\n        /**\n         * Set up client cache event handlers\n         */\n        setupEventHandlers: function () {\n            var self = this;\n\n            // Handle cached response submission\n            ClientCache.on('submitted', function (data) {\n                self.handleCachedResponseSubmitted(data);\n            });\n\n            // Handle retry events\n            ClientCache.on('retrying', function (data) {\n                self.showNotification('info', self.strings.pendingsubmissions + ': ' + data.count);\n            });\n\n            // Handle retry completion\n            ClientCache.on('retryComplete', function (data) {\n                var successCount = data.results.filter(function (r) {\n                    return r.success;\n                }).length;\n                if (successCount > 0) {\n                    self.showNotification('success', successCount + ' cached response(s) submitted');\n                }\n            });\n        },\n\n        /**\n         * Set up offline indicator UI element\n         */\n        setupOfflineIndicator: function () {\n            // Create offline indicator if it doesn't exist\n            if ($('#offline-indicator').length === 0) {\n                var indicator = $('<div id=\"offline-indicator\" class=\"offline-indicator\" style=\"display: none;\">' +\n                    '<span class=\"offline-icon\">&#9888;</span>' +\n                    '<span class=\"offline-text\"></span>' +\n                    '<span class=\"pending-count\"></span>' +\n                    '</div>');\n                $('#quiz-status').after(indicator);\n            }\n\n            // Listen for online/offline events\n            var self = this;\n            window.addEventListener('online', function () {\n                self.handleOnlineStatusChange(true);\n            });\n            window.addEventListener('offline', function () {\n                self.handleOnlineStatusChange(false);\n            });\n\n            // Check initial status\n            this.isOnline = navigator.onLine;\n            this.updateOfflineIndicator();\n        },\n\n        /**\n         * Handle online/offline status change\n         *\n         * @param {boolean} online Whether we're online\n         */\n        handleOnlineStatusChange: function (online) {\n            this.isOnline = online;\n            this.updateOfflineIndicator();\n\n            if (online) {\n                // Try to reconnect\n                ConnectionManager.reconnect().catch(function () {\n                    // Reconnection will be retried automatically\n                });\n            }\n        },\n\n        /**\n         * Handle connection status change from connection manager\n         *\n         * @param {Object} data Status change data\n         */\n        handleConnectionStatusChange: function (data) {\n            var status = data.status;\n            var transport = data.transport;\n\n            if (status === ConnectionManager.STATUS.CONNECTED) {\n                this.isOnline = true;\n                this.updateOfflineIndicator();\n                // Update transport indicator if needed\n                this.updateTransportIndicator(transport);\n            } else if (status === ConnectionManager.STATUS.RECONNECTING) {\n                this.showReconnectingIndicator();\n            } else if (status === ConnectionManager.STATUS.DISCONNECTED) {\n                this.isOnline = false;\n                this.updateOfflineIndicator();\n            }\n        },\n\n        /**\n         * Update offline indicator display\n         */\n        updateOfflineIndicator: function () {\n            var indicator = $('#offline-indicator');\n            var textSpan = indicator.find('.offline-text');\n            var pendingSpan = indicator.find('.pending-count');\n\n            if (!this.isOnline) {\n                textSpan.text(this.strings.offline);\n                indicator.removeClass('reconnecting').addClass('offline').show();\n            } else {\n                indicator.hide();\n            }\n\n            // Update pending count\n            var stats = ClientCache.getStats();\n            if (stats.pending > 0) {\n                pendingSpan.text(' (' + stats.pending + ' pending)').show();\n                indicator.show();\n            } else {\n                pendingSpan.hide();\n            }\n        },\n\n        /**\n         * Show reconnecting indicator\n         */\n        showReconnectingIndicator: function () {\n            var indicator = $('#offline-indicator');\n            indicator.find('.offline-text').text(this.strings.reconnecting);\n            indicator.removeClass('offline').addClass('reconnecting').show();\n        },\n\n        /**\n         * Update transport indicator (SSE vs polling)\n         *\n         * @param {string} transport Transport type\n         */\n        updateTransportIndicator: function (transport) {\n            var transportIndicator = $('#transport-indicator');\n            if (transportIndicator.length === 0) {\n                transportIndicator = $('<span id=\"transport-indicator\" class=\"transport-indicator\"></span>');\n                $('#quiz-status').append(transportIndicator);\n            }\n\n            if (transport === ConnectionManager.TRANSPORT.SSE) {\n                transportIndicator.text('Real-time').addClass('realtime');\n            } else if (transport === ConnectionManager.TRANSPORT.POLLING) {\n                transportIndicator.text('Polling').removeClass('realtime');\n            }\n        },\n\n        /**\n         * Handle state update from server\n         *\n         * @param {Object} data State update data\n         */\n        handleStateUpdate: function (data) {\n            // Sync timer if we have timer info\n            if (data.timelimit > 0 && data.timeremaining !== undefined) {\n                this.syncServerTime({\n                    timerremaining: data.timeremaining,\n                    timestamp: data.timestamp || (Date.now() / 1000),\n                });\n            }\n\n            if (data.question) {\n                this.updateQuestionDisplay({\n                    success: true,\n                    status: data.status,\n                    question: data.question,\n                });\n            }\n\n            if (data.status === STATE.COMPLETED) {\n                this.handleSessionCompleted(data);\n            } else if (data.status === STATE.PAUSED) {\n                this.handleSessionPaused(data);\n            }\n        },\n\n        /**\n         * Handle question broadcast from server\n         *\n         * @param {Object} data Question data\n         */\n        handleQuestionBroadcast: function (data) {\n            var question = data.question;\n            var questionId = question.id || data.questionid;\n\n            // Check if this is a NEW question (reset answered state for new questions)\n            if (questionId && this.currentQuestionId !== questionId) {\n                this.currentQuestionId = questionId;\n                // New question - user hasn't answered yet (unless cached)\n            }\n\n            // Check if user has already answered this question\n            if (questionId && this.answeredQuestions[questionId]) {\n                question.answered = true;\n            }\n\n            this.currentQuestion = question;\n            this.displayQuestion(question);\n\n            // Start local countdown timer with timelimit from server\n            // Timer is fully client-side - server validates on submission\n            var timelimit = data.timelimit || (question && question.timelimit) || 0;\n            if (timelimit > 0 && !question.answered) {\n                this.startLocalCountdown(timelimit);\n            }\n        },\n\n        /**\n         * Handle session started event\n         *\n         * @param {Object} data Session data\n         */\n        handleSessionStarted: function (data) {\n            $('#quiz-status').removeClass('alert-warning').addClass('alert-info');\n            if (data.question) {\n                this.currentQuestion = data.question;\n                this.displayQuestion(data.question);\n            }\n        },\n\n        /**\n         * Handle session paused event\n         *\n         * @param {Object} data Session data\n         */\n        handleSessionPaused: function (data) {\n            var container = $('#question-container');\n            container.find('.submit-answer-btn').prop('disabled', true);\n            this.showNotification('warning', 'Quiz paused by instructor');\n\n            // Show paused overlay\n            if ($('.paused-overlay').length === 0) {\n                container.append('<div class=\"paused-overlay\"><span>Quiz Paused</span></div>');\n            }\n\n            // Pause local countdown\n            this.pauseLocalCountdown();\n\n            // Store remaining time if provided\n            if (data.timerRemaining !== undefined) {\n                this.pausedTimerRemaining = data.timerRemaining;\n            }\n        },\n\n        /**\n         * Handle session resumed event\n         *\n         * @param {Object} data Session data\n         */\n        handleSessionResumed: function (data) {\n            var container = $('#question-container');\n            container.find('.submit-answer-btn').prop('disabled', false);\n            container.find('.paused-overlay').remove();\n            this.showNotification('info', 'Quiz resumed');\n\n            // Resume local countdown\n            if (data.timerRemaining !== undefined) {\n                this.resumeLocalCountdown(data.timerRemaining);\n            } else {\n                this.resumeLocalCountdown();\n            }\n        },\n\n        /**\n         * Handle session completed event\n         *\n         * @param {Object} data Session data\n         */\n        handleSessionCompleted: function (data) {\n            var container = $('#question-container');\n            var statusDiv = $('#quiz-status');\n\n            statusDiv.removeClass('alert-info').addClass('alert-success');\n\n            var scoreText = data.score !== undefined ? ' Your score: ' + data.score : '';\n            statusDiv.html(this.strings.quizcompleted + scoreText);\n\n            container.html('<div class=\"alert alert-success\">' +\n                '<h4>' + this.strings.quizcompleted + '</h4>' +\n                (data.score !== undefined ? '<p>Your score: ' + data.score + '</p>' : '') +\n                '</div>');\n\n            this.stopPolling();\n            ConnectionManager.disconnect();\n        },\n\n        /**\n         * Handle reconnection\n         */\n        handleReconnected: function () {\n            this.isOnline = true;\n            this.updateOfflineIndicator();\n            this.showNotification('success', this.strings.connectionrestored);\n\n            // Request current state\n            ConnectionManager.send('getstatus', {\n                sessionid: this.sessionId,\n            }).then(function (response) {\n                if (response.success && response.session) {\n                    this.handleStateUpdate(response.session);\n                }\n                return null;\n            }.bind(this)).catch(function () {\n                // Ignore errors, state will sync on next update\n            });\n        },\n\n        /**\n         * Handle disconnection\n         */\n        handleDisconnected: function () {\n            this.isOnline = false;\n            this.updateOfflineIndicator();\n        },\n\n        /**\n         * Handle cached response submitted\n         *\n         * @param {Object} data Submission data\n         */\n        handleCachedResponseSubmitted: function (data) {\n            this.showNotification('success', 'Cached response submitted: ' + data.id);\n            this.updateOfflineIndicator();\n        },\n\n        /**\n         * Submit answer with optimistic UI update\n         */\n        submitAnswer: function () {\n            var self = this;\n            var selectedAnswer = $('input[name=\"answer\"]:checked').val();\n\n            if (!selectedAnswer) {\n                Notification.alert(this.strings.error, this.strings.selectanswer);\n                return;\n            }\n\n            if (!this.currentQuestion) {\n                return;\n            }\n\n            var questionId = this.currentQuestion.id;\n            var clientTimestamp = Date.now();\n\n            // Optimistic UI update (Requirement 8.5)\n            this.showOptimisticSubmission();\n\n            // Disable submit button to prevent double submission\n            $('.submit-answer-btn').prop('disabled', true);\n\n            // Check if we're online\n            if (!this.isOnline || !ConnectionManager.getStatus().connected) {\n                // Store in cache for later submission (Requirement 4.5)\n                this.submitOffline(questionId, selectedAnswer, clientTimestamp);\n                return;\n            }\n\n            // Submit via connection manager\n            ConnectionManager.send('submitanswer', {\n                sessionid: this.sessionId,\n                questionid: questionId,\n                answer: selectedAnswer,\n                clienttimestamp: clientTimestamp,\n            }).then(function (response) {\n                self.handleSubmissionResponse(response);\n                return null;\n            }).catch(function (error) {\n                // Network error - cache the response\n                self.submitOffline(questionId, selectedAnswer, clientTimestamp);\n                // eslint-disable-next-line no-console\n                console.warn('Submission failed, cached offline:', error);\n            });\n        },\n\n        /**\n         * Show optimistic UI update before server confirmation (Requirement 8.5)\n         */\n        showOptimisticSubmission: function () {\n            var container = $('#question-container');\n\n            // Add submitting state\n            container.addClass('submitting');\n\n            // Show optimistic feedback\n            var feedbackDiv = container.find('.optimistic-feedback');\n            if (feedbackDiv.length === 0) {\n                feedbackDiv = $('<div class=\"optimistic-feedback\">' +\n                    '<span class=\"spinner\"></span> Submitting...' +\n                    '</div>');\n                container.find('.submit-answer-btn').after(feedbackDiv);\n            }\n            feedbackDiv.show();\n        },\n\n        /**\n         * Submit response offline\n         *\n         * @param {number} questionId Question ID\n         * @param {string} answer Selected answer\n         * @param {number} clientTimestamp Client timestamp\n         */\n        submitOffline: function (questionId, answer, clientTimestamp) {\n            var self = this;\n\n            // Show offline submission feedback\n            this.showNotification('info', this.strings.submittingoffline);\n\n            ClientCache.storeResponse({\n                sessionId: this.sessionId,\n                questionId: questionId,\n                answer: answer,\n                clientTimestamp: clientTimestamp,\n            }).then(function () {\n                self.showOfflineSubmissionConfirmation();\n                self.updateOfflineIndicator();\n                return null;\n            }).catch(function (error) {\n                // eslint-disable-next-line no-console\n                console.error('Failed to cache response:', error);\n                Notification.exception({ message: 'Failed to save response offline' });\n                $('.submit-answer-btn').prop('disabled', false);\n            });\n        },\n\n        /**\n         * Show offline submission confirmation\n         */\n        showOfflineSubmissionConfirmation: function () {\n            var container = $('#question-container');\n            container.removeClass('submitting');\n            container.find('.optimistic-feedback').remove();\n\n            container.html(\n                '<div class=\"alert alert-info\">' +\n                '<h4>' + this.strings.answersubmitted + '</h4>' +\n                '<p>' + this.strings.offline + '</p>' +\n                '<p>' + this.strings.waitingnextquestion + '</p>' +\n                '</div>',\n            );\n        },\n\n        /**\n         * Handle submission response from server\n         *\n         * @param {Object} response Server response\n         */\n        handleSubmissionResponse: function (response) {\n            var container = $('#question-container');\n            container.removeClass('submitting');\n            container.find('.optimistic-feedback').remove();\n\n            if (response.success) {\n                // Mark this question as answered so SSE won't overwrite\n                if (this.currentQuestion && this.currentQuestion.id) {\n                    this.answeredQuestions[this.currentQuestion.id] = true;\n                }\n\n                var message = response.iscorrect ? this.strings.correct : this.strings.incorrect;\n                var alertClass = response.iscorrect ? 'success' : 'warning';\n\n                var html = '<div class=\"alert alert-' + alertClass + '\">' +\n                    '<h4>' + message + '</h4>';\n\n                if (response.correctanswer) {\n                    html += '<p>' + this.strings.correctanswer + ': ' + response.correctanswer + '</p>';\n                }\n\n                if (response.islate) {\n                    html += '<p class=\"text-muted\"><em>Response recorded as late</em></p>';\n                }\n\n                html += '<p>' + this.strings.waitingnextquestion + '</p>' +\n                    '</div>';\n\n                container.html(html);\n\n                // Visual confirmation (Requirement 2.4)\n                this.showVisualConfirmation(response.iscorrect);\n            } else {\n                // Handle error\n                var errorMsg = response.error || '';\n                if (errorMsg.toLowerCase().indexOf('already') !== -1 || \n                    errorMsg.toLowerCase().indexOf('duplicate') !== -1) {\n                    // Already answered - show friendly message\n                    container.html('<div class=\"alert alert-info\">' + this.strings.alreadyanswered + '</div>');\n                } else if (errorMsg.toLowerCase().indexOf('not active') !== -1) {\n                    // Session not active\n                    container.html('<div class=\"alert alert-warning\">Session is not active</div>');\n                } else {\n                    // Other errors - show as notification instead of exception popup\n                    this.showNotification('error', errorMsg || 'Error submitting answer');\n                    $('.submit-answer-btn').prop('disabled', false);\n                }\n            }\n        },\n\n        /**\n         * Show visual confirmation of answer submission (Requirement 2.4)\n         *\n         * @param {boolean} isCorrect Whether the answer was correct\n         */\n        showVisualConfirmation: function (isCorrect) {\n            var confirmationClass = isCorrect ? 'confirmation-correct' : 'confirmation-incorrect';\n\n            // Create confirmation overlay\n            var overlay = $('<div class=\"submission-confirmation ' + confirmationClass + '\">' +\n                '<span class=\"confirmation-icon\">' + (isCorrect ? '✓' : '✗') + '</span>' +\n                '</div>');\n\n            $('body').append(overlay);\n\n            // Animate and remove\n            setTimeout(function () {\n                overlay.addClass('fade-out');\n                setTimeout(function () {\n                    overlay.remove();\n                }, 300);\n            }, 500);\n        },\n\n        /**\n         * Show notification message\n         *\n         * @param {string} type Notification type (success, info, warning, error)\n         * @param {string} message Message to display\n         */\n        showNotification: function (type, message) {\n            var notificationArea = $('#quiz-notifications');\n            if (notificationArea.length === 0) {\n                notificationArea = $('<div id=\"quiz-notifications\" class=\"quiz-notifications\"></div>');\n                $('#quiz-status').before(notificationArea);\n            }\n\n            var alertClass = 'alert-' + (type === 'error' ? 'danger' : type);\n            var notification = $('<div class=\"alert ' + alertClass + ' notification-toast\">' + message + '</div>');\n\n            notificationArea.append(notification);\n\n            // Auto-dismiss after 3 seconds\n            setTimeout(function () {\n                notification.fadeOut(function () {\n                    $(this).remove();\n                });\n            }, 3000);\n        },\n\n        /**\n         * Update question display\n         *\n         * @param {Object} response Server response with question data\n         */\n        updateQuestionDisplay: function (response) {\n            var container = $('#question-container');\n            var statusDiv = $('#quiz-status');\n\n            if (!response.success || response.status !== 'active') {\n                container.html('');\n                if (response.status === 'completed') {\n                    statusDiv.removeClass('alert-info').addClass('alert-success');\n                    statusDiv.html(this.strings.quizcompleted);\n                    this.stopPolling();\n                } else if (response.status === 'paused') {\n                    statusDiv.html('Quiz is paused');\n                } else {\n                    statusDiv.html(this.strings.waitingnextquestion);\n                }\n                return;\n            }\n\n            var question = response.question;\n\n            if (!question) {\n                container.html('<p>' + this.strings.waitingnextquestion + '</p>');\n                return;\n            }\n\n            // Check if this is a new question\n            if (this.currentQuestion === null || this.currentQuestion.id !== question.id) {\n                this.currentQuestion = question;\n                this.displayQuestion(question);\n            }\n\n            // Update timer\n            this.updateTimer(question.timeremaining);\n\n            // Update question number\n            statusDiv.html('Question ' + question.number + ' of ' + question.total);\n        },\n\n        /**\n         * Display a question\n         *\n         * @param {Object} question Question data\n         */\n        displayQuestion: function (question) {\n            var html = '<div class=\"question-text mb-4\">';\n            html += '<h4>' + question.text + '</h4>';\n            html += '</div>';\n\n            if (question.answered) {\n                html += '<div class=\"alert alert-info\">' + this.strings.alreadyanswered + '</div>';\n            } else {\n                html += '<form id=\"answer-form\">';\n                html += '<div class=\"question-options\">';\n\n                for (var i = 0; i < question.options.length; i++) {\n                    var option = question.options[i];\n                    html += '<div class=\"quiz-option\" data-option=\"' + option.key + '\">';\n                    html += '<label class=\"quiz-option-label\">';\n                    html += '<input type=\"radio\" name=\"answer\" value=\"' + option.key + '\" required> ';\n                    html += '<span class=\"option-key\">' + option.key + '</span>';\n                    html += '<span class=\"option-text\">' + option.text + '</span>';\n                    html += '</label>';\n                    html += '</div>';\n                }\n\n                html += '</div>';\n                html += '<button type=\"button\" class=\"btn btn-primary btn-lg submit-answer-btn mt-3\">';\n                html += this.strings.answersubmitted ? 'Submit Answer' : 'Submit Answer';\n                html += '</button>';\n                html += '</form>';\n            }\n\n            $('#question-container').html(html);\n        },\n\n        /**\n         * Update timer display (called by local countdown)\n         *\n         * @param {number} seconds Seconds remaining\n         */\n        updateTimerDisplay: function (seconds) {\n            var display = $('#timer-display');\n\n            if (seconds <= 0) {\n                display.text('0:00');\n                display.removeClass('warning').addClass('danger');\n                return;\n            }\n\n            var minutes = Math.floor(seconds / 60);\n            var secs = Math.floor(seconds % 60);\n            var timeStr = minutes + ':' + (secs < 10 ? '0' : '') + secs;\n\n            display.text(timeStr);\n\n            if (seconds <= 10) {\n                display.removeClass('warning').addClass('danger');\n            } else if (seconds <= 30) {\n                display.removeClass('danger').addClass('warning');\n            } else {\n                display.removeClass('warning danger');\n            }\n        },\n\n        /**\n         * Start local countdown timer (enterprise timer separation)\n         * Client runs its own timer to reduce server SSE traffic.\n         *\n         * @param {number} seconds Initial seconds remaining\n         */\n        startLocalCountdown: function (seconds) {\n            var self = this;\n\n            // Stop any existing countdown\n            if (this.countdownTimer) {\n                clearInterval(this.countdownTimer);\n                this.countdownTimer = null;\n            }\n\n            // Initialize timer state\n            this.timerState.serverTimeRemaining = seconds;\n            this.timerState.clientStartTime = Date.now();\n            this.timerState.isRunning = true;\n            this.timerState.isPaused = false;\n\n            // Update display immediately\n            this.updateTimerDisplay(seconds);\n\n            // Start client-side countdown (runs every 100ms for smooth updates)\n            this.countdownTimer = setInterval(function () {\n                if (!self.timerState.isRunning || self.timerState.isPaused) {\n                    return;\n                }\n\n                // Calculate elapsed time on client\n                var clientElapsed = (Date.now() - self.timerState.clientStartTime) / 1000;\n                var remaining = Math.max(0, self.timerState.serverTimeRemaining - clientElapsed);\n\n                self.updateTimerDisplay(remaining);\n\n                // Stop when timer reaches 0\n                if (remaining <= 0) {\n                    self.stopLocalCountdown();\n                }\n            }, 100); // 100ms for smooth visual updates\n        },\n\n        /**\n         * Stop local countdown timer\n         */\n        stopLocalCountdown: function () {\n            if (this.countdownTimer) {\n                clearInterval(this.countdownTimer);\n                this.countdownTimer = null;\n            }\n            this.timerState.isRunning = false;\n        },\n\n        /**\n         * Pause local countdown timer\n         */\n        pauseLocalCountdown: function () {\n            this.timerState.isPaused = true;\n            // Store remaining time when paused\n            var clientElapsed = (Date.now() - this.timerState.clientStartTime) / 1000;\n            this.timerState.serverTimeRemaining = Math.max(0, this.timerState.serverTimeRemaining - clientElapsed);\n            this.timerState.clientStartTime = Date.now();\n        },\n\n        /**\n         * Resume local countdown timer\n         *\n         * @param {number} seconds Seconds remaining from server (optional)\n         */\n        resumeLocalCountdown: function (seconds) {\n            if (seconds !== undefined) {\n                this.timerState.serverTimeRemaining = seconds;\n            }\n            this.timerState.clientStartTime = Date.now();\n            this.timerState.isPaused = false;\n        },\n\n        /**\n         * Sync server time and correct client drift (enterprise timer separation)\n         * Called on timer_sync events from server (sent every ~30s or on key events)\n         *\n         * @param {Object} data Timer sync data from server\n         */\n        syncServerTime: function (data) {\n            var serverRemaining = data.timerremaining;\n            var serverTimestamp = data.timestamp;\n\n            // Calculate what client thinks the time should be\n            var clientElapsed = (Date.now() - this.timerState.clientStartTime) / 1000;\n            var clientRemaining = Math.max(0, this.timerState.serverTimeRemaining - clientElapsed);\n\n            // Calculate drift (difference between server and client)\n            var drift = Math.abs(serverRemaining - clientRemaining);\n\n            // Only correct if drift > 2 seconds (enterprise threshold)\n            if (drift > 2 || !this.timerState.isRunning) {\n                // eslint-disable-next-line no-console\n                console.log('Timer sync: correcting drift of', drift.toFixed(1), 'seconds');\n                this.timerState.serverTimeRemaining = serverRemaining;\n                this.timerState.clientStartTime = Date.now();\n                this.timerState.serverTimestamp = serverTimestamp;\n            }\n\n            this.timerState.lastSyncTime = Date.now();\n\n            // Start countdown if not running\n            if (!this.timerState.isRunning && serverRemaining > 0) {\n                this.startLocalCountdown(serverRemaining);\n            }\n        },\n\n        /**\n         * Update timer (legacy method - starts local countdown)\n         *\n         * @param {number} seconds Seconds remaining\n         */\n        updateTimer: function (seconds) {\n            if (seconds === undefined || seconds === null) {\n                return;\n            }\n            // Start or sync local countdown\n            if (!this.timerState.isRunning) {\n                this.startLocalCountdown(seconds);\n            } else {\n                // Sync with new value\n                this.syncServerTime({ timerremaining: seconds, timestamp: Date.now() / 1000 });\n            }\n        },\n\n        /**\n         * Get current question via SSE connection\n         * Legacy polling removed - all data now comes via SSE events\n         * This method is kept for initial state fetch on connect failures\n         */\n        startLegacyPolling: function () {\n            // SSE-only mode: No polling fallback\n            // Show connection error notification\n            this.showNotification('error',\n                'SSE connection required. Please ensure your browser supports Server-Sent Events.');\n        },\n\n        /**\n         * Get current question - now SSE-only\n         * This method is kept for backward compatibility but SSE events\n         * are the primary source for question data\n         */\n        getCurrentQuestion: function () {\n            var self = this;\n\n            // Try ConnectionManager send for state refresh\n            ConnectionManager.send('getstatus', {\n                sessionid: this.sessionId,\n            }).then(function (response) {\n                if (response && response.success && response.session) {\n                    self.handleStateUpdate(response.session);\n                }\n                return null;\n            }).catch(function () {\n                // SSE events will provide the data, ignore errors\n            });\n        },\n\n        /**\n         * Stop polling\n         */\n        stopPolling: function () {\n            if (this.pollingTimer) {\n                clearInterval(this.pollingTimer);\n                this.pollingTimer = null;\n            }\n            if (this.countdownTimer) {\n                clearInterval(this.countdownTimer);\n                this.countdownTimer = null;\n            }\n        },\n    };\n\n    return {\n        /**\n         * Initialize the quiz module\n         *\n         * @param {number} cmid Course module ID\n         * @param {number} sessionid Session ID\n         * @param {number} pollinginterval Polling interval\n         * @return {Promise} Resolves when initialized\n         */\n        init: function (cmid, sessionid, pollinginterval) {\n            return Quiz.init(cmid, sessionid, pollinginterval);\n        },\n    };\n});\n"],"names":["define","$","Ajax","Notification","Str","ConnectionManager","ClientCache","STATE","Quiz","cmid","sessionId","currentQuestion","currentQuestionId","pollingTimer","countdownTimer","isOnline","pendingSubmission","strings","answeredQuestions","timerState","serverTimeRemaining","serverTimestamp","clientStartTime","isRunning","isPaused","lastSyncTime","init","options","sessionid","pollinginterval","timelimit","timeremaining","questionid","hasanswered","self","this","arguments","loadStrings","then","maxRetries","retryDelay","setConnectionManager","getInstance","pollInterval","setupEventHandlers","setupConnectionHandlers","setupOfflineIndicator","document","on","submitAnswer","e","preventDefault","find","prop","addClass","siblings","removeClass","startLocalCountdown","text","setTimeout","catch","error","console","startLegacyPolling","get_strings","key","component","answersubmitted","correct","incorrect","correctanswer","waitingnextquestion","quizcompleted","alreadyanswered","selectanswer","offline","reconnecting","connectionrestored","submittingoffline","pendingsubmissions","data","handleConnectionStatusChange","handleStateUpdate","handleQuestionBroadcast","handleSessionStarted","handleSessionPaused","handleSessionResumed","handleSessionCompleted","syncServerTime","handleReconnected","handleDisconnected","handleCachedResponseSubmitted","showNotification","count","successCount","results","filter","r","success","length","indicator","after","window","addEventListener","handleOnlineStatusChange","navigator","onLine","updateOfflineIndicator","online","reconnect","status","transport","STATUS","CONNECTED","updateTransportIndicator","RECONNECTING","showReconnectingIndicator","DISCONNECTED","textSpan","pendingSpan","hide","show","stats","getStats","pending","transportIndicator","append","TRANSPORT","SSE","POLLING","undefined","timerremaining","timestamp","Date","now","question","updateQuestionDisplay","questionId","id","answered","displayQuestion","container","pauseLocalCountdown","timerRemaining","pausedTimerRemaining","remove","resumeLocalCountdown","statusDiv","scoreText","score","html","stopPolling","disconnect","send","response","session","bind","selectedAnswer","val","clientTimestamp","showOptimisticSubmission","getStatus","connected","answer","clienttimestamp","handleSubmissionResponse","submitOffline","warn","alert","feedbackDiv","storeResponse","showOfflineSubmissionConfirmation","exception","message","iscorrect","islate","showVisualConfirmation","errorMsg","toLowerCase","indexOf","isCorrect","overlay","type","notificationArea","before","notification","fadeOut","updateTimer","number","total","i","option","updateTimerDisplay","seconds","display","minutes","Math","floor","secs","timeStr","clearInterval","setInterval","clientElapsed","remaining","max","stopLocalCountdown","serverRemaining","clientRemaining","drift","abs","log","toFixed","getCurrentQuestion"],"mappings":"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"}