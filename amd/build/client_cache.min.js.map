{"version":3,"file":"client_cache.min.js","sources":["../src/client_cache.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Client Cache for offline response storage\r\n *\r\n * Provides IndexedDB-based storage for pending quiz responses during network\r\n * interruptions. Automatically retries submission when connectivity is restored.\r\n *\r\n * Requirements: 4.1, 4.2, 4.3, 4.5\r\n *\r\n * @module     mod_classengage/client_cache\r\n * @copyright  2025 Danielle\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\ndefine(['jquery'], function($) {\r\n\r\n    /**\r\n     * Database configuration\r\n     * @type {Object}\r\n     */\r\n    var DB_CONFIG = {\r\n        name: 'classengage_cache',\r\n        version: 1,\r\n        storeName: 'pending_responses'\r\n    };\r\n\r\n    /**\r\n     * Default configuration options\r\n     * @type {Object}\r\n     */\r\n    var DEFAULTS = {\r\n        maxRetries: 5,\r\n        retryDelay: 1000,\r\n        maxCacheAge: 3600000 // 1 hour in milliseconds\r\n    };\r\n\r\n    /**\r\n     * Client Cache constructor\r\n     * @constructor\r\n     */\r\n    function ClientCache() {\r\n        this.db = null;\r\n        this.options = $.extend({}, DEFAULTS);\r\n        this.isInitialized = false;\r\n        this.connectionManager = null;\r\n\r\n        // Statistics tracking\r\n        this.stats = {\r\n            stored: 0,\r\n            submitted: 0,\r\n            failed: 0,\r\n            pending: 0\r\n        };\r\n\r\n        // Event handlers\r\n        this.eventHandlers = {};\r\n    }\r\n\r\n    /**\r\n     * Initialize the client cache\r\n     *\r\n     * @param {Object} options Configuration options\r\n     * @return {Promise} Resolves when initialized\r\n     */\r\n    ClientCache.prototype.init = function(options) {\r\n        var self = this;\r\n\r\n        this.options = $.extend({}, DEFAULTS, options || {});\r\n\r\n        // eslint-disable-next-line no-unused-vars\r\n        return new Promise(function(resolve, reject) {\r\n            // Check IndexedDB support\r\n            if (!self.isIndexedDBSupported()) {\r\n                // Fallback to in-memory storage\r\n                self.useMemoryFallback();\r\n                self.isInitialized = true;\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            var request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);\r\n\r\n            request.onerror = function(event) {\r\n                // Fallback to in-memory storage on error\r\n                // eslint-disable-next-line no-console\r\n                console.warn('IndexedDB error, using memory fallback:', event);\r\n                self.useMemoryFallback();\r\n                self.isInitialized = true;\r\n                resolve();\r\n            };\r\n\r\n            request.onsuccess = function(event) {\r\n                self.db = event.target.result;\r\n                self.isInitialized = true;\r\n                self.updatePendingCount();\r\n                resolve();\r\n            };\r\n\r\n            request.onupgradeneeded = function(event) {\r\n                var db = event.target.result;\r\n\r\n                // Create object store for pending responses\r\n                if (!db.objectStoreNames.contains(DB_CONFIG.storeName)) {\r\n                    var store = db.createObjectStore(DB_CONFIG.storeName, {keyPath: 'id'});\r\n                    store.createIndex('sessionId', 'sessionId', {unique: false});\r\n                    store.createIndex('timestamp', 'timestamp', {unique: false});\r\n                    store.createIndex('status', 'status', {unique: false});\r\n                }\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Check if IndexedDB is supported\r\n     *\r\n     * @return {boolean} True if supported\r\n     */\r\n    ClientCache.prototype.isIndexedDBSupported = function() {\r\n        return typeof indexedDB !== 'undefined';\r\n    };\r\n\r\n    /**\r\n     * Use in-memory fallback when IndexedDB is not available\r\n     *\r\n     * @private\r\n     */\r\n    ClientCache.prototype.useMemoryFallback = function() {\r\n        this.memoryStore = [];\r\n        this.db = null;\r\n    };\r\n\r\n    /**\r\n     * Generate a unique ID for a response\r\n     *\r\n     * @return {string} Unique ID\r\n     * @private\r\n     */\r\n    ClientCache.prototype.generateId = function() {\r\n        return 'resp_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);\r\n    };\r\n\r\n    /**\r\n     * Store a pending response\r\n     *\r\n     * @param {Object} response Response data\r\n     * @return {Promise} Resolves with stored response\r\n     */\r\n    ClientCache.prototype.storeResponse = function(response) {\r\n        var self = this;\r\n\r\n        var pendingResponse = {\r\n            id: this.generateId(),\r\n            sessionId: response.sessionId,\r\n            questionId: response.questionId,\r\n            answer: response.answer,\r\n            timestamp: Date.now(),\r\n            clientTimestamp: response.clientTimestamp || Date.now(),\r\n            retryCount: 0,\r\n            status: 'pending',\r\n            lastError: null\r\n        };\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                self.memoryStore.push(pendingResponse);\r\n                self.stats.stored++;\r\n                self.stats.pending++;\r\n                self.emit('stored', pendingResponse);\r\n                resolve(pendingResponse);\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var request = store.add(pendingResponse);\r\n\r\n            request.onsuccess = function() {\r\n                self.stats.stored++;\r\n                self.stats.pending++;\r\n                self.emit('stored', pendingResponse);\r\n                resolve(pendingResponse);\r\n            };\r\n\r\n            request.onerror = function() {\r\n                reject(new Error('Failed to store response'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Get all pending responses\r\n     *\r\n     * @return {Promise<Array>} Resolves with array of pending responses\r\n     */\r\n    ClientCache.prototype.getPendingResponses = function() {\r\n        var self = this;\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                var pending = self.memoryStore.filter(function(r) {\r\n                    return r.status === 'pending';\r\n                });\r\n                resolve(pending);\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readonly');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var index = store.index('status');\r\n            var request = index.getAll('pending');\r\n\r\n            request.onsuccess = function(event) {\r\n                resolve(event.target.result || []);\r\n            };\r\n\r\n            request.onerror = function() {\r\n                reject(new Error('Failed to get pending responses'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Get pending responses for a specific session\r\n     *\r\n     * @param {number} sessionId Session ID\r\n     * @return {Promise<Array>} Resolves with array of pending responses\r\n     */\r\n    ClientCache.prototype.getPendingBySession = function(sessionId) {\r\n        return this.getPendingResponses().then(function(responses) {\r\n            return responses.filter(function(r) {\r\n                return r.sessionId === sessionId;\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Mark a response as submitted\r\n     *\r\n     * @param {string} responseId Response ID\r\n     * @return {Promise} Resolves when marked\r\n     */\r\n    ClientCache.prototype.markSubmitted = function(responseId) {\r\n        var self = this;\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                var index = self.memoryStore.findIndex(function(r) {\r\n                    return r.id === responseId;\r\n                });\r\n                if (index !== -1) {\r\n                    self.memoryStore[index].status = 'submitted';\r\n                    self.stats.submitted++;\r\n                    self.stats.pending = Math.max(0, self.stats.pending - 1);\r\n                    self.emit('submitted', {id: responseId});\r\n                }\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var getRequest = store.get(responseId);\r\n\r\n            getRequest.onsuccess = function(event) {\r\n                var response = event.target.result;\r\n                if (response) {\r\n                    response.status = 'submitted';\r\n                    var updateRequest = store.put(response);\r\n                    updateRequest.onsuccess = function() {\r\n                        self.stats.submitted++;\r\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\r\n                        self.emit('submitted', {id: responseId});\r\n                        resolve();\r\n                    };\r\n                    updateRequest.onerror = function() {\r\n                        reject(new Error('Failed to update response'));\r\n                    };\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            getRequest.onerror = function() {\r\n                reject(new Error('Failed to get response'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Mark a response as failed\r\n     *\r\n     * @param {string} responseId Response ID\r\n     * @param {string} errorMsg Error message\r\n     * @return {Promise} Resolves when marked\r\n     */\r\n    ClientCache.prototype.markFailed = function(responseId, errorMsg) {\r\n        var self = this;\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                var index = self.memoryStore.findIndex(function(r) {\r\n                    return r.id === responseId;\r\n                });\r\n                if (index !== -1) {\r\n                    self.memoryStore[index].retryCount++;\r\n                    self.memoryStore[index].lastError = errorMsg;\r\n                    if (self.memoryStore[index].retryCount >= self.options.maxRetries) {\r\n                        self.memoryStore[index].status = 'failed';\r\n                        self.stats.failed++;\r\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\r\n                        self.emit('failed', {id: responseId, error: errorMsg});\r\n                    }\r\n                }\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var getRequest = store.get(responseId);\r\n\r\n            getRequest.onsuccess = function(event) {\r\n                var response = event.target.result;\r\n                if (response) {\r\n                    response.retryCount++;\r\n                    response.lastError = errorMsg;\r\n                    if (response.retryCount >= self.options.maxRetries) {\r\n                        response.status = 'failed';\r\n                        self.stats.failed++;\r\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\r\n                        self.emit('failed', {id: responseId, error: errorMsg});\r\n                    }\r\n                    var updateRequest = store.put(response);\r\n                    updateRequest.onsuccess = function() {\r\n                        resolve();\r\n                    };\r\n                    updateRequest.onerror = function() {\r\n                        reject(new Error('Failed to update response'));\r\n                    };\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            getRequest.onerror = function() {\r\n                reject(new Error('Failed to get response'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Remove a response from cache\r\n     *\r\n     * @param {string} responseId Response ID\r\n     * @return {Promise} Resolves when removed\r\n     */\r\n    ClientCache.prototype.removeResponse = function(responseId) {\r\n        var self = this;\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                var index = self.memoryStore.findIndex(function(r) {\r\n                    return r.id === responseId;\r\n                });\r\n                if (index !== -1) {\r\n                    var removed = self.memoryStore.splice(index, 1)[0];\r\n                    if (removed.status === 'pending') {\r\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\r\n                    }\r\n                }\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var request = store.delete(responseId);\r\n\r\n            request.onsuccess = function() {\r\n                self.updatePendingCount();\r\n                resolve();\r\n            };\r\n\r\n            request.onerror = function() {\r\n                reject(new Error('Failed to remove response'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Clear all pending responses\r\n     *\r\n     * @return {Promise} Resolves when cleared\r\n     */\r\n    ClientCache.prototype.clear = function() {\r\n        var self = this;\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                self.memoryStore = [];\r\n                self.stats.pending = 0;\r\n                self.emit('cleared', {});\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var request = store.clear();\r\n\r\n            request.onsuccess = function() {\r\n                self.stats.pending = 0;\r\n                self.emit('cleared', {});\r\n                resolve();\r\n            };\r\n\r\n            request.onerror = function() {\r\n                reject(new Error('Failed to clear cache'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Clean up old cached responses\r\n     *\r\n     * @return {Promise} Resolves when cleanup complete\r\n     */\r\n    ClientCache.prototype.cleanup = function() {\r\n        var self = this;\r\n        var cutoffTime = Date.now() - this.options.maxCacheAge;\r\n\r\n        return new Promise(function(resolve, reject) {\r\n            if (!self.isInitialized) {\r\n                reject(new Error('Cache not initialized'));\r\n                return;\r\n            }\r\n\r\n            if (self.memoryStore) {\r\n                // Memory fallback\r\n                self.memoryStore = self.memoryStore.filter(function(r) {\r\n                    return r.timestamp > cutoffTime;\r\n                });\r\n                self.updatePendingCount();\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\r\n            var store = transaction.objectStore(DB_CONFIG.storeName);\r\n            var index = store.index('timestamp');\r\n            var range = IDBKeyRange.upperBound(cutoffTime);\r\n            var request = index.openCursor(range);\r\n\r\n            request.onsuccess = function(event) {\r\n                var cursor = event.target.result;\r\n                if (cursor) {\r\n                    cursor.delete();\r\n                    cursor.continue();\r\n                } else {\r\n                    self.updatePendingCount();\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            request.onerror = function() {\r\n                reject(new Error('Failed to cleanup cache'));\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Update pending count in stats\r\n     *\r\n     * @private\r\n     */\r\n    ClientCache.prototype.updatePendingCount = function() {\r\n        var self = this;\r\n\r\n        this.getPendingResponses().then(function(responses) {\r\n            self.stats.pending = responses.length;\r\n        }).catch(function() {\r\n            // Ignore errors\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Get cache statistics\r\n     *\r\n     * @return {Object} Cache statistics\r\n     */\r\n    ClientCache.prototype.getStats = function() {\r\n        return $.extend({}, this.stats);\r\n    };\r\n\r\n    /**\r\n     * Set connection manager for automatic retry\r\n     *\r\n     * @param {Object} connectionManager Connection manager instance\r\n     */\r\n    ClientCache.prototype.setConnectionManager = function(connectionManager) {\r\n        var self = this;\r\n        this.connectionManager = connectionManager;\r\n\r\n        // Listen for reconnection events\r\n        if (connectionManager && typeof connectionManager.on === 'function') {\r\n            connectionManager.on('connected', function() {\r\n                self.retryPendingResponses();\r\n            });\r\n\r\n            connectionManager.on('reconnected', function() {\r\n                self.retryPendingResponses();\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Retry all pending responses\r\n     *\r\n     * @return {Promise} Resolves when all retries complete\r\n     */\r\n    ClientCache.prototype.retryPendingResponses = function() {\r\n        var self = this;\r\n\r\n        return this.getPendingResponses().then(function(responses) {\r\n            if (responses.length === 0) {\r\n                return Promise.resolve([]);\r\n            }\r\n\r\n            self.emit('retrying', {count: responses.length});\r\n\r\n            var promises = responses.map(function(response) {\r\n                return self.submitCachedResponse(response);\r\n            });\r\n\r\n            return Promise.all(promises);\r\n        }).then(function(results) {\r\n            self.emit('retryComplete', {results: results});\r\n            return results;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Submit a cached response to the server\r\n     *\r\n     * @param {Object} cachedResponse Cached response object\r\n     * @return {Promise} Resolves with submission result\r\n     * @private\r\n     */\r\n    ClientCache.prototype.submitCachedResponse = function(cachedResponse) {\r\n        var self = this;\r\n\r\n        if (!this.connectionManager) {\r\n            return Promise.reject(new Error('No connection manager'));\r\n        }\r\n\r\n        return this.connectionManager.send('submitanswer', {\r\n            sessionid: cachedResponse.sessionId,\r\n            questionid: cachedResponse.questionId,\r\n            answer: cachedResponse.answer,\r\n            clienttimestamp: cachedResponse.clientTimestamp\r\n        }).then(function(response) {\r\n            if (response.success) {\r\n                return self.markSubmitted(cachedResponse.id).then(function() {\r\n                    return {\r\n                        id: cachedResponse.id,\r\n                        success: true,\r\n                        islate: response.islate || false\r\n                    };\r\n                });\r\n            } else {\r\n                // Check if it's a permanent failure (duplicate, session ended, etc.)\r\n                if (self.isPermanentFailure(response.error)) {\r\n                    return self.removeResponse(cachedResponse.id).then(function() {\r\n                        return {\r\n                            id: cachedResponse.id,\r\n                            success: false,\r\n                            error: response.error,\r\n                            permanent: true\r\n                        };\r\n                    });\r\n                }\r\n                return self.markFailed(cachedResponse.id, response.error).then(function() {\r\n                    return {\r\n                        id: cachedResponse.id,\r\n                        success: false,\r\n                        error: response.error\r\n                    };\r\n                });\r\n            }\r\n        }).catch(function(error) {\r\n            return self.markFailed(cachedResponse.id, error.message).then(function() {\r\n                return {\r\n                    id: cachedResponse.id,\r\n                    success: false,\r\n                    error: error.message\r\n                };\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Check if an error is a permanent failure\r\n     *\r\n     * @param {string} error Error message\r\n     * @return {boolean} True if permanent failure\r\n     * @private\r\n     */\r\n    ClientCache.prototype.isPermanentFailure = function(error) {\r\n        if (!error) {\r\n            return false;\r\n        }\r\n        var permanentErrors = [\r\n            'Duplicate submission',\r\n            'Session not found',\r\n            'Session not active',\r\n            'Question not found',\r\n            'already answered'\r\n        ];\r\n        return permanentErrors.some(function(msg) {\r\n            return error.indexOf(msg) !== -1;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Check if there are pending responses\r\n     *\r\n     * @return {boolean} True if there are pending responses\r\n     */\r\n    ClientCache.prototype.hasPending = function() {\r\n        return this.stats.pending > 0;\r\n    };\r\n\r\n    /**\r\n     * Register event handler\r\n     *\r\n     * @param {string} event Event name\r\n     * @param {Function} callback Callback function\r\n     */\r\n    ClientCache.prototype.on = function(event, callback) {\r\n        if (!this.eventHandlers[event]) {\r\n            this.eventHandlers[event] = [];\r\n        }\r\n        this.eventHandlers[event].push(callback);\r\n    };\r\n\r\n    /**\r\n     * Remove event handler\r\n     *\r\n     * @param {string} event Event name\r\n     * @param {Function} callback Callback function to remove\r\n     */\r\n    ClientCache.prototype.off = function(event, callback) {\r\n        if (!this.eventHandlers[event]) {\r\n            return;\r\n        }\r\n\r\n        if (callback) {\r\n            this.eventHandlers[event] = this.eventHandlers[event].filter(function(cb) {\r\n                return cb !== callback;\r\n            });\r\n        } else {\r\n            delete this.eventHandlers[event];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Emit event to handlers\r\n     *\r\n     * @param {string} event Event name\r\n     * @param {Object} data Event data\r\n     * @private\r\n     */\r\n    ClientCache.prototype.emit = function(event, data) {\r\n        var handlers = this.eventHandlers[event];\r\n        if (handlers) {\r\n            handlers.forEach(function(callback) {\r\n                try {\r\n                    callback(data);\r\n                } catch (e) {\r\n                    // eslint-disable-next-line no-console\r\n                    console.error('Error in event handler for ' + event + ':', e);\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    // Singleton instance\r\n    var instance = null;\r\n\r\n    return {\r\n        /**\r\n         * Get or create ClientCache instance\r\n         *\r\n         * @return {ClientCache} Client cache instance\r\n         */\r\n        getInstance: function() {\r\n            if (!instance) {\r\n                instance = new ClientCache();\r\n            }\r\n            return instance;\r\n        },\r\n\r\n        /**\r\n         * Initialize client cache\r\n         *\r\n         * @param {Object} options Configuration options\r\n         * @return {Promise} Resolves when initialized\r\n         */\r\n        init: function(options) {\r\n            return this.getInstance().init(options);\r\n        },\r\n\r\n        /**\r\n         * Store a pending response\r\n         *\r\n         * @param {Object} response Response data\r\n         * @return {Promise} Resolves with stored response\r\n         */\r\n        storeResponse: function(response) {\r\n            return this.getInstance().storeResponse(response);\r\n        },\r\n\r\n        /**\r\n         * Get all pending responses\r\n         *\r\n         * @return {Promise<Array>} Resolves with array of pending responses\r\n         */\r\n        getPendingResponses: function() {\r\n            return this.getInstance().getPendingResponses();\r\n        },\r\n\r\n        /**\r\n         * Get pending responses for a session\r\n         *\r\n         * @param {number} sessionId Session ID\r\n         * @return {Promise<Array>} Resolves with array of pending responses\r\n         */\r\n        getPendingBySession: function(sessionId) {\r\n            return this.getInstance().getPendingBySession(sessionId);\r\n        },\r\n\r\n        /**\r\n         * Mark a response as submitted\r\n         *\r\n         * @param {string} responseId Response ID\r\n         * @return {Promise} Resolves when marked\r\n         */\r\n        markSubmitted: function(responseId) {\r\n            return this.getInstance().markSubmitted(responseId);\r\n        },\r\n\r\n        /**\r\n         * Mark a response as failed\r\n         *\r\n         * @param {string} responseId Response ID\r\n         * @param {string} error Error message\r\n         * @return {Promise} Resolves when marked\r\n         */\r\n        markFailed: function(responseId, error) {\r\n            return this.getInstance().markFailed(responseId, error);\r\n        },\r\n\r\n        /**\r\n         * Remove a response from cache\r\n         *\r\n         * @param {string} responseId Response ID\r\n         * @return {Promise} Resolves when removed\r\n         */\r\n        removeResponse: function(responseId) {\r\n            return this.getInstance().removeResponse(responseId);\r\n        },\r\n\r\n        /**\r\n         * Clear all pending responses\r\n         *\r\n         * @return {Promise} Resolves when cleared\r\n         */\r\n        clear: function() {\r\n            return this.getInstance().clear();\r\n        },\r\n\r\n        /**\r\n         * Clean up old cached responses\r\n         *\r\n         * @return {Promise} Resolves when cleanup complete\r\n         */\r\n        cleanup: function() {\r\n            return this.getInstance().cleanup();\r\n        },\r\n\r\n        /**\r\n         * Get cache statistics\r\n         *\r\n         * @return {Object} Cache statistics\r\n         */\r\n        getStats: function() {\r\n            return this.getInstance().getStats();\r\n        },\r\n\r\n        /**\r\n         * Set connection manager for automatic retry\r\n         *\r\n         * @param {Object} connectionManager Connection manager instance\r\n         */\r\n        setConnectionManager: function(connectionManager) {\r\n            this.getInstance().setConnectionManager(connectionManager);\r\n        },\r\n\r\n        /**\r\n         * Retry all pending responses\r\n         *\r\n         * @return {Promise} Resolves when all retries complete\r\n         */\r\n        retryPendingResponses: function() {\r\n            return this.getInstance().retryPendingResponses();\r\n        },\r\n\r\n        /**\r\n         * Check if there are pending responses\r\n         *\r\n         * @return {boolean} True if there are pending responses\r\n         */\r\n        hasPending: function() {\r\n            return this.getInstance().hasPending();\r\n        },\r\n\r\n        /**\r\n         * Register event handler\r\n         *\r\n         * @param {string} event Event name\r\n         * @param {Function} callback Callback function\r\n         */\r\n        on: function(event, callback) {\r\n            this.getInstance().on(event, callback);\r\n        },\r\n\r\n        /**\r\n         * Remove event handler\r\n         *\r\n         * @param {string} event Event name\r\n         * @param {Function} callback Callback function\r\n         */\r\n        off: function(event, callback) {\r\n            this.getInstance().off(event, callback);\r\n        }\r\n    };\r\n});\r\n"],"names":["define","$","DB_CONFIG","DEFAULTS","maxRetries","retryDelay","maxCacheAge","ClientCache","db","options","extend","isInitialized","connectionManager","stats","stored","submitted","failed","pending","eventHandlers","prototype","init","self","this","Promise","resolve","reject","isIndexedDBSupported","useMemoryFallback","request","indexedDB","open","onerror","event","console","warn","onsuccess","target","result","updatePendingCount","onupgradeneeded","objectStoreNames","contains","store","createObjectStore","keyPath","createIndex","unique","memoryStore","generateId","Date","now","Math","random","toString","substring","storeResponse","response","pendingResponse","id","sessionId","questionId","answer","timestamp","clientTimestamp","retryCount","status","lastError","push","emit","transaction","objectStore","add","Error","getPendingResponses","filter","r","index","getAll","getPendingBySession","then","responses","markSubmitted","responseId","findIndex","max","getRequest","get","updateRequest","put","markFailed","errorMsg","error","removeResponse","splice","delete","clear","cleanup","cutoffTime","range","IDBKeyRange","upperBound","openCursor","cursor","continue","length","catch","getStats","setConnectionManager","on","retryPendingResponses","count","promises","map","submitCachedResponse","all","results","cachedResponse","send","sessionid","questionid","clienttimestamp","success","islate","isPermanentFailure","permanent","message","some","msg","indexOf","hasPending","callback","off","cb","data","handlers","forEach","e","instance","getInstance"],"mappings":"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"}