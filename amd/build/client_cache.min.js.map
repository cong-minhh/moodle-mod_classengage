{"version":3,"file":"client_cache.min.js","sources":["../src/client_cache.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Client Cache for offline response storage\n *\n * Provides IndexedDB-based storage for pending quiz responses during network\n * interruptions. Automatically retries submission when connectivity is restored.\n *\n * Requirements: 4.1, 4.2, 4.3, 4.5\n *\n * @module     mod_classengage/client_cache\n * @copyright  2025 Danielle\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\ndefine(['jquery'], function($) {\n\n    /**\n     * Database configuration\n     * @type {Object}\n     */\n    var DB_CONFIG = {\n        name: 'classengage_cache',\n        version: 1,\n        storeName: 'pending_responses',\n    };\n\n    /**\n     * Default configuration options\n     * @type {Object}\n     */\n    var DEFAULTS = {\n        maxRetries: 5,\n        retryDelay: 1000,\n        maxCacheAge: 3600000, // 1 hour in milliseconds\n    };\n\n    /**\n     * Client Cache constructor\n     * @constructor\n     */\n    function ClientCache() {\n        this.db = null;\n        this.options = $.extend({}, DEFAULTS);\n        this.isInitialized = false;\n        this.connectionManager = null;\n\n        // Statistics tracking\n        this.stats = {\n            stored: 0,\n            submitted: 0,\n            failed: 0,\n            pending: 0,\n        };\n\n        // Event handlers\n        this.eventHandlers = {};\n    }\n\n    /**\n     * Initialize the client cache\n     *\n     * @param {Object} options Configuration options\n     * @return {Promise} Resolves when initialized\n     */\n    ClientCache.prototype.init = function(options) {\n        var self = this;\n\n        this.options = $.extend({}, DEFAULTS, options || {});\n\n        // eslint-disable-next-line no-unused-vars\n        return new Promise(function(resolve, reject) {\n            // Check IndexedDB support\n            if (!self.isIndexedDBSupported()) {\n                // Fallback to in-memory storage\n                self.useMemoryFallback();\n                self.isInitialized = true;\n                resolve();\n                return;\n            }\n\n            var request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);\n\n            request.onerror = function(event) {\n                // Fallback to in-memory storage on error\n                // eslint-disable-next-line no-console\n                console.warn('IndexedDB error, using memory fallback:', event);\n                self.useMemoryFallback();\n                self.isInitialized = true;\n                resolve();\n            };\n\n            request.onsuccess = function(event) {\n                self.db = event.target.result;\n                self.isInitialized = true;\n                self.updatePendingCount();\n                resolve();\n            };\n\n            request.onupgradeneeded = function(event) {\n                var db = event.target.result;\n\n                // Create object store for pending responses\n                if (!db.objectStoreNames.contains(DB_CONFIG.storeName)) {\n                    var store = db.createObjectStore(DB_CONFIG.storeName, {keyPath: 'id'});\n                    store.createIndex('sessionId', 'sessionId', {unique: false});\n                    store.createIndex('timestamp', 'timestamp', {unique: false});\n                    store.createIndex('status', 'status', {unique: false});\n                }\n            };\n        });\n    };\n\n    /**\n     * Check if IndexedDB is supported\n     *\n     * @return {boolean} True if supported\n     */\n    ClientCache.prototype.isIndexedDBSupported = function() {\n        return typeof indexedDB !== 'undefined';\n    };\n\n    /**\n     * Use in-memory fallback when IndexedDB is not available\n     *\n     * @private\n     */\n    ClientCache.prototype.useMemoryFallback = function() {\n        this.memoryStore = [];\n        this.db = null;\n    };\n\n    /**\n     * Generate a unique ID for a response\n     *\n     * @return {string} Unique ID\n     * @private\n     */\n    ClientCache.prototype.generateId = function() {\n        return 'resp_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);\n    };\n\n    /**\n     * Store a pending response\n     *\n     * @param {Object} response Response data\n     * @return {Promise} Resolves with stored response\n     */\n    ClientCache.prototype.storeResponse = function(response) {\n        var self = this;\n\n        var pendingResponse = {\n            id: this.generateId(),\n            sessionId: response.sessionId,\n            questionId: response.questionId,\n            answer: response.answer,\n            timestamp: Date.now(),\n            clientTimestamp: response.clientTimestamp || Date.now(),\n            retryCount: 0,\n            status: 'pending',\n            lastError: null,\n        };\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                self.memoryStore.push(pendingResponse);\n                self.stats.stored++;\n                self.stats.pending++;\n                self.emit('stored', pendingResponse);\n                resolve(pendingResponse);\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var request = store.add(pendingResponse);\n\n            request.onsuccess = function() {\n                self.stats.stored++;\n                self.stats.pending++;\n                self.emit('stored', pendingResponse);\n                resolve(pendingResponse);\n            };\n\n            request.onerror = function() {\n                reject(new Error('Failed to store response'));\n            };\n        });\n    };\n\n    /**\n     * Get all pending responses\n     *\n     * @return {Promise<Array>} Resolves with array of pending responses\n     */\n    ClientCache.prototype.getPendingResponses = function() {\n        var self = this;\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                var pending = self.memoryStore.filter(function(r) {\n                    return r.status === 'pending';\n                });\n                resolve(pending);\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readonly');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var index = store.index('status');\n            var request = index.getAll('pending');\n\n            request.onsuccess = function(event) {\n                resolve(event.target.result || []);\n            };\n\n            request.onerror = function() {\n                reject(new Error('Failed to get pending responses'));\n            };\n        });\n    };\n\n    /**\n     * Get pending responses for a specific session\n     *\n     * @param {number} sessionId Session ID\n     * @return {Promise<Array>} Resolves with array of pending responses\n     */\n    ClientCache.prototype.getPendingBySession = function(sessionId) {\n        return this.getPendingResponses().then(function(responses) {\n            return responses.filter(function(r) {\n                return r.sessionId === sessionId;\n            });\n        });\n    };\n\n    /**\n     * Mark a response as submitted\n     *\n     * @param {string} responseId Response ID\n     * @return {Promise} Resolves when marked\n     */\n    ClientCache.prototype.markSubmitted = function(responseId) {\n        var self = this;\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                var index = self.memoryStore.findIndex(function(r) {\n                    return r.id === responseId;\n                });\n                if (index !== -1) {\n                    self.memoryStore[index].status = 'submitted';\n                    self.stats.submitted++;\n                    self.stats.pending = Math.max(0, self.stats.pending - 1);\n                    self.emit('submitted', {id: responseId});\n                }\n                resolve();\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var getRequest = store.get(responseId);\n\n            getRequest.onsuccess = function(event) {\n                var response = event.target.result;\n                if (response) {\n                    response.status = 'submitted';\n                    var updateRequest = store.put(response);\n                    updateRequest.onsuccess = function() {\n                        self.stats.submitted++;\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\n                        self.emit('submitted', {id: responseId});\n                        resolve();\n                    };\n                    updateRequest.onerror = function() {\n                        reject(new Error('Failed to update response'));\n                    };\n                } else {\n                    resolve();\n                }\n            };\n\n            getRequest.onerror = function() {\n                reject(new Error('Failed to get response'));\n            };\n        });\n    };\n\n    /**\n     * Mark a response as failed\n     *\n     * @param {string} responseId Response ID\n     * @param {string} errorMsg Error message\n     * @return {Promise} Resolves when marked\n     */\n    ClientCache.prototype.markFailed = function(responseId, errorMsg) {\n        var self = this;\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                var index = self.memoryStore.findIndex(function(r) {\n                    return r.id === responseId;\n                });\n                if (index !== -1) {\n                    self.memoryStore[index].retryCount++;\n                    self.memoryStore[index].lastError = errorMsg;\n                    if (self.memoryStore[index].retryCount >= self.options.maxRetries) {\n                        self.memoryStore[index].status = 'failed';\n                        self.stats.failed++;\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\n                        self.emit('failed', {id: responseId, error: errorMsg});\n                    }\n                }\n                resolve();\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var getRequest = store.get(responseId);\n\n            getRequest.onsuccess = function(event) {\n                var response = event.target.result;\n                if (response) {\n                    response.retryCount++;\n                    response.lastError = errorMsg;\n                    if (response.retryCount >= self.options.maxRetries) {\n                        response.status = 'failed';\n                        self.stats.failed++;\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\n                        self.emit('failed', {id: responseId, error: errorMsg});\n                    }\n                    var updateRequest = store.put(response);\n                    updateRequest.onsuccess = function() {\n                        resolve();\n                    };\n                    updateRequest.onerror = function() {\n                        reject(new Error('Failed to update response'));\n                    };\n                } else {\n                    resolve();\n                }\n            };\n\n            getRequest.onerror = function() {\n                reject(new Error('Failed to get response'));\n            };\n        });\n    };\n\n    /**\n     * Remove a response from cache\n     *\n     * @param {string} responseId Response ID\n     * @return {Promise} Resolves when removed\n     */\n    ClientCache.prototype.removeResponse = function(responseId) {\n        var self = this;\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                var index = self.memoryStore.findIndex(function(r) {\n                    return r.id === responseId;\n                });\n                if (index !== -1) {\n                    var removed = self.memoryStore.splice(index, 1)[0];\n                    if (removed.status === 'pending') {\n                        self.stats.pending = Math.max(0, self.stats.pending - 1);\n                    }\n                }\n                resolve();\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var request = store.delete(responseId);\n\n            request.onsuccess = function() {\n                self.updatePendingCount();\n                resolve();\n            };\n\n            request.onerror = function() {\n                reject(new Error('Failed to remove response'));\n            };\n        });\n    };\n\n    /**\n     * Clear all pending responses\n     *\n     * @return {Promise} Resolves when cleared\n     */\n    ClientCache.prototype.clear = function() {\n        var self = this;\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                self.memoryStore = [];\n                self.stats.pending = 0;\n                self.emit('cleared', {});\n                resolve();\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var request = store.clear();\n\n            request.onsuccess = function() {\n                self.stats.pending = 0;\n                self.emit('cleared', {});\n                resolve();\n            };\n\n            request.onerror = function() {\n                reject(new Error('Failed to clear cache'));\n            };\n        });\n    };\n\n    /**\n     * Clean up old cached responses\n     *\n     * @return {Promise} Resolves when cleanup complete\n     */\n    ClientCache.prototype.cleanup = function() {\n        var self = this;\n        var cutoffTime = Date.now() - this.options.maxCacheAge;\n\n        return new Promise(function(resolve, reject) {\n            if (!self.isInitialized) {\n                reject(new Error('Cache not initialized'));\n                return;\n            }\n\n            if (self.memoryStore) {\n                // Memory fallback\n                self.memoryStore = self.memoryStore.filter(function(r) {\n                    return r.timestamp > cutoffTime;\n                });\n                self.updatePendingCount();\n                resolve();\n                return;\n            }\n\n            var transaction = self.db.transaction([DB_CONFIG.storeName], 'readwrite');\n            var store = transaction.objectStore(DB_CONFIG.storeName);\n            var index = store.index('timestamp');\n            var range = IDBKeyRange.upperBound(cutoffTime);\n            var request = index.openCursor(range);\n\n            request.onsuccess = function(event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    cursor.delete();\n                    cursor.continue();\n                } else {\n                    self.updatePendingCount();\n                    resolve();\n                }\n            };\n\n            request.onerror = function() {\n                reject(new Error('Failed to cleanup cache'));\n            };\n        });\n    };\n\n    /**\n     * Update pending count in stats\n     *\n     * @private\n     */\n    ClientCache.prototype.updatePendingCount = function() {\n        var self = this;\n\n        this.getPendingResponses().then(function(responses) {\n            self.stats.pending = responses.length;\n        }).catch(function() {\n            // Ignore errors\n        });\n    };\n\n    /**\n     * Get cache statistics\n     *\n     * @return {Object} Cache statistics\n     */\n    ClientCache.prototype.getStats = function() {\n        return $.extend({}, this.stats);\n    };\n\n    /**\n     * Set connection manager for automatic retry\n     *\n     * @param {Object} connectionManager Connection manager instance\n     */\n    ClientCache.prototype.setConnectionManager = function(connectionManager) {\n        var self = this;\n        this.connectionManager = connectionManager;\n\n        // Listen for reconnection events\n        if (connectionManager && typeof connectionManager.on === 'function') {\n            connectionManager.on('connected', function() {\n                self.retryPendingResponses();\n            });\n\n            connectionManager.on('reconnected', function() {\n                self.retryPendingResponses();\n            });\n        }\n    };\n\n    /**\n     * Retry all pending responses\n     *\n     * @return {Promise} Resolves when all retries complete\n     */\n    ClientCache.prototype.retryPendingResponses = function() {\n        var self = this;\n\n        return this.getPendingResponses().then(function(responses) {\n            if (responses.length === 0) {\n                return Promise.resolve([]);\n            }\n\n            self.emit('retrying', {count: responses.length});\n\n            var promises = responses.map(function(response) {\n                return self.submitCachedResponse(response);\n            });\n\n            return Promise.all(promises);\n        }).then(function(results) {\n            self.emit('retryComplete', {results: results});\n            return results;\n        });\n    };\n\n    /**\n     * Submit a cached response to the server\n     *\n     * @param {Object} cachedResponse Cached response object\n     * @return {Promise} Resolves with submission result\n     * @private\n     */\n    ClientCache.prototype.submitCachedResponse = function(cachedResponse) {\n        var self = this;\n\n        if (!this.connectionManager) {\n            return Promise.reject(new Error('No connection manager'));\n        }\n\n        return this.connectionManager.send('submitanswer', {\n            sessionid: cachedResponse.sessionId,\n            questionid: cachedResponse.questionId,\n            answer: cachedResponse.answer,\n            clienttimestamp: cachedResponse.clientTimestamp,\n        }).then(function(response) {\n            if (response.success) {\n                return self.markSubmitted(cachedResponse.id).then(function() {\n                    return {\n                        id: cachedResponse.id,\n                        success: true,\n                        islate: response.islate || false,\n                    };\n                });\n            } else {\n                // Check if it's a permanent failure (duplicate, session ended, etc.)\n                if (self.isPermanentFailure(response.error)) {\n                    return self.removeResponse(cachedResponse.id).then(function() {\n                        return {\n                            id: cachedResponse.id,\n                            success: false,\n                            error: response.error,\n                            permanent: true,\n                        };\n                    });\n                }\n                return self.markFailed(cachedResponse.id, response.error).then(function() {\n                    return {\n                        id: cachedResponse.id,\n                        success: false,\n                        error: response.error,\n                    };\n                });\n            }\n        }).catch(function(error) {\n            return self.markFailed(cachedResponse.id, error.message).then(function() {\n                return {\n                    id: cachedResponse.id,\n                    success: false,\n                    error: error.message,\n                };\n            });\n        });\n    };\n\n    /**\n     * Check if an error is a permanent failure\n     *\n     * @param {string} error Error message\n     * @return {boolean} True if permanent failure\n     * @private\n     */\n    ClientCache.prototype.isPermanentFailure = function(error) {\n        if (!error) {\n            return false;\n        }\n        var permanentErrors = [\n            'Duplicate submission',\n            'Session not found',\n            'Session not active',\n            'Question not found',\n            'already answered',\n        ];\n        return permanentErrors.some(function(msg) {\n            return error.indexOf(msg) !== -1;\n        });\n    };\n\n    /**\n     * Check if there are pending responses\n     *\n     * @return {boolean} True if there are pending responses\n     */\n    ClientCache.prototype.hasPending = function() {\n        return this.stats.pending > 0;\n    };\n\n    /**\n     * Register event handler\n     *\n     * @param {string} event Event name\n     * @param {Function} callback Callback function\n     */\n    ClientCache.prototype.on = function(event, callback) {\n        if (!this.eventHandlers[event]) {\n            this.eventHandlers[event] = [];\n        }\n        this.eventHandlers[event].push(callback);\n    };\n\n    /**\n     * Remove event handler\n     *\n     * @param {string} event Event name\n     * @param {Function} callback Callback function to remove\n     */\n    ClientCache.prototype.off = function(event, callback) {\n        if (!this.eventHandlers[event]) {\n            return;\n        }\n\n        if (callback) {\n            this.eventHandlers[event] = this.eventHandlers[event].filter(function(cb) {\n                return cb !== callback;\n            });\n        } else {\n            delete this.eventHandlers[event];\n        }\n    };\n\n    /**\n     * Emit event to handlers\n     *\n     * @param {string} event Event name\n     * @param {Object} data Event data\n     * @private\n     */\n    ClientCache.prototype.emit = function(event, data) {\n        var handlers = this.eventHandlers[event];\n        if (handlers) {\n            handlers.forEach(function(callback) {\n                try {\n                    callback(data);\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    console.error('Error in event handler for ' + event + ':', e);\n                }\n            });\n        }\n    };\n\n    // Singleton instance\n    var instance = null;\n\n    return {\n        /**\n         * Get or create ClientCache instance\n         *\n         * @return {ClientCache} Client cache instance\n         */\n        getInstance: function() {\n            if (!instance) {\n                instance = new ClientCache();\n            }\n            return instance;\n        },\n\n        /**\n         * Initialize client cache\n         *\n         * @param {Object} options Configuration options\n         * @return {Promise} Resolves when initialized\n         */\n        init: function(options) {\n            return this.getInstance().init(options);\n        },\n\n        /**\n         * Store a pending response\n         *\n         * @param {Object} response Response data\n         * @return {Promise} Resolves with stored response\n         */\n        storeResponse: function(response) {\n            return this.getInstance().storeResponse(response);\n        },\n\n        /**\n         * Get all pending responses\n         *\n         * @return {Promise<Array>} Resolves with array of pending responses\n         */\n        getPendingResponses: function() {\n            return this.getInstance().getPendingResponses();\n        },\n\n        /**\n         * Get pending responses for a session\n         *\n         * @param {number} sessionId Session ID\n         * @return {Promise<Array>} Resolves with array of pending responses\n         */\n        getPendingBySession: function(sessionId) {\n            return this.getInstance().getPendingBySession(sessionId);\n        },\n\n        /**\n         * Mark a response as submitted\n         *\n         * @param {string} responseId Response ID\n         * @return {Promise} Resolves when marked\n         */\n        markSubmitted: function(responseId) {\n            return this.getInstance().markSubmitted(responseId);\n        },\n\n        /**\n         * Mark a response as failed\n         *\n         * @param {string} responseId Response ID\n         * @param {string} error Error message\n         * @return {Promise} Resolves when marked\n         */\n        markFailed: function(responseId, error) {\n            return this.getInstance().markFailed(responseId, error);\n        },\n\n        /**\n         * Remove a response from cache\n         *\n         * @param {string} responseId Response ID\n         * @return {Promise} Resolves when removed\n         */\n        removeResponse: function(responseId) {\n            return this.getInstance().removeResponse(responseId);\n        },\n\n        /**\n         * Clear all pending responses\n         *\n         * @return {Promise} Resolves when cleared\n         */\n        clear: function() {\n            return this.getInstance().clear();\n        },\n\n        /**\n         * Clean up old cached responses\n         *\n         * @return {Promise} Resolves when cleanup complete\n         */\n        cleanup: function() {\n            return this.getInstance().cleanup();\n        },\n\n        /**\n         * Get cache statistics\n         *\n         * @return {Object} Cache statistics\n         */\n        getStats: function() {\n            return this.getInstance().getStats();\n        },\n\n        /**\n         * Set connection manager for automatic retry\n         *\n         * @param {Object} connectionManager Connection manager instance\n         */\n        setConnectionManager: function(connectionManager) {\n            this.getInstance().setConnectionManager(connectionManager);\n        },\n\n        /**\n         * Retry all pending responses\n         *\n         * @return {Promise} Resolves when all retries complete\n         */\n        retryPendingResponses: function() {\n            return this.getInstance().retryPendingResponses();\n        },\n\n        /**\n         * Check if there are pending responses\n         *\n         * @return {boolean} True if there are pending responses\n         */\n        hasPending: function() {\n            return this.getInstance().hasPending();\n        },\n\n        /**\n         * Register event handler\n         *\n         * @param {string} event Event name\n         * @param {Function} callback Callback function\n         */\n        on: function(event, callback) {\n            this.getInstance().on(event, callback);\n        },\n\n        /**\n         * Remove event handler\n         *\n         * @param {string} event Event name\n         * @param {Function} callback Callback function\n         */\n        off: function(event, callback) {\n            this.getInstance().off(event, callback);\n        },\n    };\n});\n"],"names":["define","$","DB_CONFIG","DEFAULTS","maxRetries","retryDelay","maxCacheAge","ClientCache","db","options","extend","isInitialized","connectionManager","stats","stored","submitted","failed","pending","eventHandlers","prototype","init","self","this","Promise","resolve","reject","isIndexedDBSupported","useMemoryFallback","request","indexedDB","open","onerror","event","console","warn","onsuccess","target","result","updatePendingCount","onupgradeneeded","objectStoreNames","contains","store","createObjectStore","keyPath","createIndex","unique","memoryStore","generateId","Date","now","Math","random","toString","substring","storeResponse","response","pendingResponse","id","sessionId","questionId","answer","timestamp","clientTimestamp","retryCount","status","lastError","push","emit","transaction","objectStore","add","Error","getPendingResponses","filter","r","index","getAll","getPendingBySession","then","responses","markSubmitted","responseId","findIndex","max","getRequest","get","updateRequest","put","markFailed","errorMsg","error","removeResponse","splice","delete","clear","cleanup","cutoffTime","range","IDBKeyRange","upperBound","openCursor","cursor","continue","length","catch","getStats","setConnectionManager","on","retryPendingResponses","count","promises","map","submitCachedResponse","all","results","cachedResponse","send","sessionid","questionid","clienttimestamp","success","islate","isPermanentFailure","permanent","message","some","msg","indexOf","hasPending","callback","off","cb","data","handlers","forEach","e","instance","getInstance"],"mappings":"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"}